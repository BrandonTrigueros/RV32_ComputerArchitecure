<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project source="3.9.0" version="1.0">
  This file is intended to be loaded by Logisim-evolution v3.9.0(https://github.com/logisim-evolution/).

  <lib desc="#Wiring" name="0">
    <tool name="Pin">
      <a name="appearance" val="classic"/>
    </tool>
    <tool name="Tunnel">
      <a name="labelfont" val="SansSerif bold 10"/>
    </tool>
    <tool name="Constant">
      <a name="facing" val="west"/>
      <a name="value" val="0x0"/>
    </tool>
  </lib>
  <lib desc="#Gates" name="1"/>
  <lib desc="#Plexers" name="2"/>
  <lib desc="#Arithmetic" name="3"/>
  <lib desc="#Memory" name="4"/>
  <lib desc="#I/O" name="5"/>
  <lib desc="#TTL" name="6"/>
  <lib desc="#TCL" name="7"/>
  <lib desc="#Base" name="8"/>
  <lib desc="#BFH-Praktika" name="9"/>
  <lib desc="#Input/Output-Extra" name="10"/>
  <lib desc="#Soc" name="11"/>
  <main name="main"/>
  <options>
    <a name="gateUndefined" val="ignore"/>
    <a name="simlimit" val="1000"/>
    <a name="simrand" val="0"/>
  </options>
  <mappings>
    <tool lib="8" map="Button2" name="Poke Tool"/>
    <tool lib="8" map="Button3" name="Menu Tool"/>
    <tool lib="8" map="Ctrl Button1" name="Menu Tool"/>
  </mappings>
  <toolbar>
    <tool lib="8" name="Poke Tool"/>
    <tool lib="8" name="Edit Tool"/>
    <tool lib="8" name="Wiring Tool"/>
    <tool lib="8" name="Text Tool"/>
    <sep/>
    <tool lib="0" name="Pin"/>
    <tool lib="0" name="Pin">
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
    </tool>
    <sep/>
    <tool lib="1" name="NOT Gate"/>
    <tool lib="1" name="AND Gate"/>
    <tool lib="1" name="OR Gate"/>
    <tool lib="1" name="XOR Gate"/>
    <tool lib="1" name="NAND Gate"/>
    <tool lib="1" name="NOR Gate"/>
    <sep/>
    <tool lib="4" name="D Flip-Flop"/>
    <tool lib="4" name="Register"/>
  </toolbar>
  <circuit name="main">
    <a name="appearance" val="logisim_evolution"/>
    <a name="circuit" val="main"/>
    <a name="circuitnamedboxfixedsize" val="true"/>
    <a name="simulationFrequency" val="1.0"/>
    <appear>
      <circ-anchor facing="east" x="50" y="50"/>
    </appear>
  </circuit>
  <circuit name="test_sdram">
    <a name="appearance" val="logisim_evolution"/>
    <a name="circuit" val="test_sdram"/>
    <a name="circuitnamedboxfixedsize" val="true"/>
    <a name="simulationFrequency" val="1.0"/>
    <comp lib="0" loc="(1020,330)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="DATA_OUT1"/>
      <a name="output" val="true"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(1020,420)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="DATA_OUT2"/>
      <a name="output" val="true"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(470,570)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="DATA_IN1"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(570,330)" name="Clock"/>
    <comp lib="0" loc="(570,390)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="OPERATION1"/>
    </comp>
    <comp lib="0" loc="(570,420)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="OPERATION2"/>
    </comp>
    <comp lib="0" loc="(570,450)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="READY1"/>
    </comp>
    <comp lib="0" loc="(570,480)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="READY2"/>
    </comp>
    <comp lib="0" loc="(570,510)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="ADDR1"/>
      <a name="radix" val="16"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(570,540)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="ADDR2"/>
      <a name="radix" val="16"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(630,630)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="DATA_IN2"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(950,260)" name="Splitter">
      <a name="bit1" val="0"/>
      <a name="bit10" val="2"/>
      <a name="bit11" val="2"/>
      <a name="bit12" val="3"/>
      <a name="bit13" val="3"/>
      <a name="bit14" val="3"/>
      <a name="bit15" val="3"/>
      <a name="bit16" val="4"/>
      <a name="bit17" val="4"/>
      <a name="bit18" val="4"/>
      <a name="bit19" val="4"/>
      <a name="bit2" val="0"/>
      <a name="bit20" val="5"/>
      <a name="bit21" val="5"/>
      <a name="bit22" val="5"/>
      <a name="bit23" val="5"/>
      <a name="bit24" val="6"/>
      <a name="bit25" val="6"/>
      <a name="bit26" val="6"/>
      <a name="bit27" val="6"/>
      <a name="bit28" val="7"/>
      <a name="bit29" val="7"/>
      <a name="bit3" val="0"/>
      <a name="bit30" val="7"/>
      <a name="bit31" val="7"/>
      <a name="bit4" val="1"/>
      <a name="bit5" val="1"/>
      <a name="bit6" val="1"/>
      <a name="bit7" val="1"/>
      <a name="bit8" val="2"/>
      <a name="bit9" val="2"/>
      <a name="facing" val="north"/>
      <a name="fanout" val="8"/>
      <a name="incoming" val="32"/>
      <a name="spacing" val="4"/>
    </comp>
    <comp lib="0" loc="(980,160)" name="Splitter">
      <a name="bit1" val="0"/>
      <a name="bit10" val="2"/>
      <a name="bit11" val="2"/>
      <a name="bit12" val="3"/>
      <a name="bit13" val="3"/>
      <a name="bit14" val="3"/>
      <a name="bit15" val="3"/>
      <a name="bit16" val="4"/>
      <a name="bit17" val="4"/>
      <a name="bit18" val="4"/>
      <a name="bit19" val="4"/>
      <a name="bit2" val="0"/>
      <a name="bit20" val="5"/>
      <a name="bit21" val="5"/>
      <a name="bit22" val="5"/>
      <a name="bit23" val="5"/>
      <a name="bit24" val="6"/>
      <a name="bit25" val="6"/>
      <a name="bit26" val="6"/>
      <a name="bit27" val="6"/>
      <a name="bit28" val="7"/>
      <a name="bit29" val="7"/>
      <a name="bit3" val="0"/>
      <a name="bit30" val="7"/>
      <a name="bit31" val="7"/>
      <a name="bit4" val="1"/>
      <a name="bit5" val="1"/>
      <a name="bit6" val="1"/>
      <a name="bit7" val="1"/>
      <a name="bit8" val="2"/>
      <a name="bit9" val="2"/>
      <a name="facing" val="north"/>
      <a name="fanout" val="8"/>
      <a name="incoming" val="32"/>
      <a name="spacing" val="4"/>
    </comp>
    <comp lib="5" loc="(570,360)" name="Button">
      <a name="label" val="RESET"/>
    </comp>
    <comp lib="5" loc="(590,320)" name="LED">
      <a name="facing" val="south"/>
    </comp>
    <comp lib="5" loc="(620,320)" name="LED">
      <a name="facing" val="south"/>
    </comp>
    <comp lib="5" loc="(660,230)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
      <a name="label" val="hex"/>
    </comp>
    <comp lib="5" loc="(690,130)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
    </comp>
    <comp lib="5" loc="(700,230)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
      <a name="label" val="hex_1"/>
    </comp>
    <comp lib="5" loc="(730,130)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
    </comp>
    <comp lib="5" loc="(740,230)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
      <a name="label" val="hex_2"/>
    </comp>
    <comp lib="5" loc="(770,130)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
    </comp>
    <comp lib="5" loc="(780,230)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
      <a name="label" val="hex_3"/>
    </comp>
    <comp lib="5" loc="(810,130)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
    </comp>
    <comp lib="5" loc="(820,230)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
      <a name="label" val="hex_4"/>
    </comp>
    <comp lib="5" loc="(850,130)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
    </comp>
    <comp lib="5" loc="(860,230)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
      <a name="label" val="hex_5"/>
    </comp>
    <comp lib="5" loc="(890,130)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
    </comp>
    <comp lib="5" loc="(900,230)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
      <a name="label" val="hex_6"/>
    </comp>
    <comp lib="5" loc="(930,130)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
    </comp>
    <comp lib="5" loc="(940,230)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
      <a name="label" val="hex_7"/>
    </comp>
    <comp lib="5" loc="(970,130)" name="Hex Digit Display">
      <a name="decimalPoint" val="false"/>
    </comp>
    <comp loc="(890,370)" name="sdram">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <wire from="(1010,330)" to="(1010,370)"/>
    <wire from="(1010,330)" to="(1020,330)"/>
    <wire from="(1010,390)" to="(1010,420)"/>
    <wire from="(1010,420)" to="(1020,420)"/>
    <wire from="(470,570)" to="(640,570)"/>
    <wire from="(570,330)" to="(590,330)"/>
    <wire from="(570,360)" to="(620,360)"/>
    <wire from="(570,390)" to="(610,390)"/>
    <wire from="(570,420)" to="(590,420)"/>
    <wire from="(570,450)" to="(670,450)"/>
    <wire from="(570,480)" to="(590,480)"/>
    <wire from="(570,510)" to="(610,510)"/>
    <wire from="(570,540)" to="(620,540)"/>
    <wire from="(590,320)" to="(590,330)"/>
    <wire from="(590,330)" to="(660,330)"/>
    <wire from="(590,420)" to="(590,430)"/>
    <wire from="(590,430)" to="(670,430)"/>
    <wire from="(590,470)" to="(590,480)"/>
    <wire from="(590,470)" to="(670,470)"/>
    <wire from="(610,390)" to="(610,410)"/>
    <wire from="(610,410)" to="(670,410)"/>
    <wire from="(610,490)" to="(610,510)"/>
    <wire from="(610,490)" to="(670,490)"/>
    <wire from="(620,320)" to="(620,360)"/>
    <wire from="(620,360)" to="(630,360)"/>
    <wire from="(620,510)" to="(620,540)"/>
    <wire from="(620,510)" to="(670,510)"/>
    <wire from="(630,360)" to="(630,390)"/>
    <wire from="(630,390)" to="(670,390)"/>
    <wire from="(630,630)" to="(660,630)"/>
    <wire from="(640,530)" to="(640,570)"/>
    <wire from="(640,530)" to="(670,530)"/>
    <wire from="(660,230)" to="(660,240)"/>
    <wire from="(660,330)" to="(660,370)"/>
    <wire from="(660,370)" to="(670,370)"/>
    <wire from="(660,550)" to="(660,630)"/>
    <wire from="(660,550)" to="(670,550)"/>
    <wire from="(690,130)" to="(690,140)"/>
    <wire from="(700,230)" to="(700,240)"/>
    <wire from="(730,130)" to="(730,140)"/>
    <wire from="(740,230)" to="(740,240)"/>
    <wire from="(770,130)" to="(770,140)"/>
    <wire from="(780,230)" to="(780,240)"/>
    <wire from="(810,130)" to="(810,140)"/>
    <wire from="(820,230)" to="(820,240)"/>
    <wire from="(850,130)" to="(850,140)"/>
    <wire from="(860,230)" to="(860,240)"/>
    <wire from="(890,130)" to="(890,140)"/>
    <wire from="(890,370)" to="(950,370)"/>
    <wire from="(890,390)" to="(980,390)"/>
    <wire from="(900,230)" to="(900,240)"/>
    <wire from="(930,130)" to="(930,140)"/>
    <wire from="(940,230)" to="(940,240)"/>
    <wire from="(950,260)" to="(950,370)"/>
    <wire from="(950,370)" to="(1010,370)"/>
    <wire from="(970,130)" to="(970,140)"/>
    <wire from="(980,160)" to="(980,390)"/>
    <wire from="(980,390)" to="(1010,390)"/>
  </circuit>
  <circuit name="test_cache_controller">
    <a name="appearance" val="logisim_evolution"/>
    <a name="circuit" val="test_cache_controller"/>
    <a name="circuitnamedboxfixedsize" val="true"/>
    <a name="simulationFrequency" val="1.0"/>
    <comp lib="0" loc="(1390,1030)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line3_state"/>
      <a name="output" val="true"/>
      <a name="width" val="2"/>
    </comp>
    <comp lib="0" loc="(1390,790)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line0_state"/>
      <a name="output" val="true"/>
      <a name="width" val="2"/>
    </comp>
    <comp lib="0" loc="(1390,870)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line1_state"/>
      <a name="output" val="true"/>
      <a name="width" val="2"/>
    </comp>
    <comp lib="0" loc="(1390,950)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line2_state"/>
      <a name="output" val="true"/>
      <a name="width" val="2"/>
    </comp>
    <comp lib="0" loc="(1420,1050)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line3_addr"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(1420,810)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line0_addr"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(1420,890)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line1_addr"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(1420,970)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line2_addr"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(1460,1070)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line3_data"/>
      <a name="output" val="true"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(1460,830)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line0_data"/>
      <a name="output" val="true"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(1460,910)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line1_data"/>
      <a name="output" val="true"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(1460,990)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_line2_data"/>
      <a name="output" val="true"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(1470,160)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="Sdram_addr"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(1480,330)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="cpu_req_addr_out"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(1510,180)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="Sdram_data_out"/>
      <a name="output" val="true"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(1550,630)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cpu_state"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(1590,650)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cache_state"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(1660,690)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_current_addr"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(1730,400)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="cache_to_cache_req_address_out"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(1740,460)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="cache_to_cache_resp_out_data"/>
      <a name="output" val="true"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(1760,730)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_evict_index"/>
      <a name="output" val="true"/>
      <a name="width" val="2"/>
    </comp>
    <comp lib="0" loc="(1800,750)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="label" val="debug_cycle_counter"/>
      <a name="output" val="true"/>
      <a name="radix" val="16"/>
      <a name="width" val="4"/>
    </comp>
    <comp lib="0" loc="(690,530)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="cpu_req_addr_in"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(700,790)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="cache_to_cache_resp_in_data"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(740,350)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="Sdram_data_in"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(740,730)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="cache_to_cache_req_address_in"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(750,510)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="cpu_rd_req_in"/>
    </comp>
    <comp lib="0" loc="(780,490)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="cpu_wr_req_in"/>
    </comp>
    <comp lib="0" loc="(790,330)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="wantedAddress"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(800,770)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="cache_to_cache_resp_in_ready"/>
    </comp>
    <comp lib="0" loc="(830,710)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="cache_to_cache_req_in"/>
    </comp>
    <comp lib="0" loc="(830,750)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="cache_to_cache_resp_in"/>
    </comp>
    <comp lib="0" loc="(880,270)" name="Clock">
      <a name="label" val="clk"/>
    </comp>
    <comp lib="0" loc="(880,310)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="label" val="priority"/>
    </comp>
    <comp lib="5" loc="(1360,1010)" name="LED">
      <a name="label" val="debug_cache_line3_valid"/>
    </comp>
    <comp lib="5" loc="(1360,770)" name="LED">
      <a name="label" val="debug_cache_line0_valid"/>
    </comp>
    <comp lib="5" loc="(1360,850)" name="LED">
      <a name="label" val="debug_cache_line1_valid"/>
    </comp>
    <comp lib="5" loc="(1360,930)" name="LED">
      <a name="label" val="debug_cache_line2_valid"/>
    </comp>
    <comp lib="5" loc="(1420,120)" name="LED">
      <a name="label" val="read_en"/>
    </comp>
    <comp lib="5" loc="(1430,290)" name="LED">
      <a name="label" val="cpu_wr_req_out"/>
    </comp>
    <comp lib="5" loc="(1440,140)" name="LED">
      <a name="label" val="write_en"/>
    </comp>
    <comp lib="5" loc="(1450,310)" name="LED">
      <a name="label" val="cpu_rd_req_out"/>
    </comp>
    <comp lib="5" loc="(1630,670)" name="LED">
      <a name="label" val="debug_cache_hit"/>
    </comp>
    <comp lib="5" loc="(1700,380)" name="LED">
      <a name="label" val="cache_to_cache_req_out"/>
    </comp>
    <comp lib="5" loc="(1700,420)" name="LED">
      <a name="label" val="cache_to_cache_resp_out"/>
    </comp>
    <comp lib="5" loc="(1720,440)" name="LED">
      <a name="label" val="cache_to_cache_resp_out_ready"/>
    </comp>
    <comp lib="5" loc="(1720,710)" name="LED">
      <a name="label" val="debug_operation_type"/>
    </comp>
    <comp lib="5" loc="(850,290)" name="Button">
      <a name="label" val="reset"/>
    </comp>
    <comp loc="(1220,390)" name="Cache_Controller">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <wire from="(1220,1010)" to="(1360,1010)"/>
    <wire from="(1220,1030)" to="(1390,1030)"/>
    <wire from="(1220,1050)" to="(1420,1050)"/>
    <wire from="(1220,1070)" to="(1460,1070)"/>
    <wire from="(1220,390)" to="(1240,390)"/>
    <wire from="(1220,410)" to="(1270,410)"/>
    <wire from="(1220,430)" to="(1300,430)"/>
    <wire from="(1220,450)" to="(1330,450)"/>
    <wire from="(1220,470)" to="(1420,470)"/>
    <wire from="(1220,490)" to="(1440,490)"/>
    <wire from="(1220,510)" to="(1470,510)"/>
    <wire from="(1220,530)" to="(1650,530)"/>
    <wire from="(1220,550)" to="(1670,550)"/>
    <wire from="(1220,570)" to="(1690,570)"/>
    <wire from="(1220,590)" to="(1710,590)"/>
    <wire from="(1220,610)" to="(1730,610)"/>
    <wire from="(1220,630)" to="(1550,630)"/>
    <wire from="(1220,650)" to="(1590,650)"/>
    <wire from="(1220,670)" to="(1630,670)"/>
    <wire from="(1220,690)" to="(1660,690)"/>
    <wire from="(1220,710)" to="(1720,710)"/>
    <wire from="(1220,730)" to="(1760,730)"/>
    <wire from="(1220,750)" to="(1800,750)"/>
    <wire from="(1220,770)" to="(1360,770)"/>
    <wire from="(1220,790)" to="(1390,790)"/>
    <wire from="(1220,810)" to="(1420,810)"/>
    <wire from="(1220,830)" to="(1460,830)"/>
    <wire from="(1220,850)" to="(1360,850)"/>
    <wire from="(1220,870)" to="(1390,870)"/>
    <wire from="(1220,890)" to="(1420,890)"/>
    <wire from="(1220,910)" to="(1460,910)"/>
    <wire from="(1220,930)" to="(1360,930)"/>
    <wire from="(1220,950)" to="(1390,950)"/>
    <wire from="(1220,970)" to="(1420,970)"/>
    <wire from="(1220,990)" to="(1460,990)"/>
    <wire from="(1240,120)" to="(1240,390)"/>
    <wire from="(1240,120)" to="(1420,120)"/>
    <wire from="(1270,140)" to="(1270,410)"/>
    <wire from="(1270,140)" to="(1440,140)"/>
    <wire from="(1300,160)" to="(1300,430)"/>
    <wire from="(1300,160)" to="(1470,160)"/>
    <wire from="(1330,180)" to="(1330,450)"/>
    <wire from="(1330,180)" to="(1510,180)"/>
    <wire from="(1420,290)" to="(1420,470)"/>
    <wire from="(1420,290)" to="(1430,290)"/>
    <wire from="(1440,310)" to="(1440,490)"/>
    <wire from="(1440,310)" to="(1450,310)"/>
    <wire from="(1470,330)" to="(1470,510)"/>
    <wire from="(1470,330)" to="(1480,330)"/>
    <wire from="(1650,380)" to="(1650,530)"/>
    <wire from="(1650,380)" to="(1700,380)"/>
    <wire from="(1670,400)" to="(1670,550)"/>
    <wire from="(1670,400)" to="(1730,400)"/>
    <wire from="(1690,420)" to="(1690,570)"/>
    <wire from="(1690,420)" to="(1700,420)"/>
    <wire from="(1710,440)" to="(1710,590)"/>
    <wire from="(1710,440)" to="(1720,440)"/>
    <wire from="(1730,460)" to="(1730,610)"/>
    <wire from="(1730,460)" to="(1740,460)"/>
    <wire from="(690,530)" to="(1000,530)"/>
    <wire from="(700,790)" to="(890,790)"/>
    <wire from="(740,350)" to="(900,350)"/>
    <wire from="(740,730)" to="(860,730)"/>
    <wire from="(750,510)" to="(1000,510)"/>
    <wire from="(780,490)" to="(1000,490)"/>
    <wire from="(790,330)" to="(910,330)"/>
    <wire from="(800,770)" to="(880,770)"/>
    <wire from="(830,710)" to="(850,710)"/>
    <wire from="(830,750)" to="(870,750)"/>
    <wire from="(850,290)" to="(930,290)"/>
    <wire from="(850,550)" to="(1000,550)"/>
    <wire from="(850,550)" to="(850,710)"/>
    <wire from="(860,570)" to="(1000,570)"/>
    <wire from="(860,570)" to="(860,730)"/>
    <wire from="(870,590)" to="(1000,590)"/>
    <wire from="(870,590)" to="(870,750)"/>
    <wire from="(880,270)" to="(940,270)"/>
    <wire from="(880,310)" to="(920,310)"/>
    <wire from="(880,610)" to="(1000,610)"/>
    <wire from="(880,610)" to="(880,770)"/>
    <wire from="(890,630)" to="(1000,630)"/>
    <wire from="(890,630)" to="(890,790)"/>
    <wire from="(900,350)" to="(900,470)"/>
    <wire from="(900,470)" to="(1000,470)"/>
    <wire from="(910,330)" to="(910,450)"/>
    <wire from="(910,450)" to="(1000,450)"/>
    <wire from="(920,310)" to="(920,430)"/>
    <wire from="(920,430)" to="(1000,430)"/>
    <wire from="(930,290)" to="(930,410)"/>
    <wire from="(930,410)" to="(1000,410)"/>
    <wire from="(940,270)" to="(940,390)"/>
    <wire from="(940,390)" to="(1000,390)"/>
  </circuit>
  <circuit name="test_fifo">
    <a name="appearance" val="logisim_evolution"/>
    <a name="circuit" val="test_fifo"/>
    <a name="circuitnamedboxfixedsize" val="true"/>
    <a name="simulationFrequency" val="1.0"/>
    <comp loc="(920,460)" name="FIFO">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
  </circuit>
  <vhdl name="msi_protocol">
library ieee;&#13;
use ieee.std_logic_1164.all;&#13;
use ieee.numeric_std.all;&#13;
&#13;
entity msi_protocol is&#13;
    port (&#13;
        clk             : in std_logic;&#13;
        reset           : in std_logic;&#13;
        cpu0_state      : in std_logic_vector(1 downto 0); -- MSI state for cpu0&#13;
        cpu1_state      : in std_logic_vector(1 downto 0); -- MSI state for cpu1&#13;
        cpu0_addr       : in std_logic_vector(31 downto 0);   -- Address from cpu0&#13;
        cpu1_addr       : in std_logic_vector(31 downto 0);   -- Address from cpu1&#13;
        invalidate_cpu0 : out std_logic;                      -- Invalidate signal for cpu0&#13;
        invalidate_cpu1 : out std_logic                       -- Invalidate signal for cpu1&#13;
    );&#13;
end msi_protocol;&#13;
&#13;
architecture Behavioral of msi_protocol is&#13;
begin&#13;
    process(clk, reset)&#13;
    begin&#13;
        if reset = '1' then&#13;
            invalidate_cpu0 &lt;= '0';&#13;
            invalidate_cpu1 &lt;= '0';&#13;
        elsif rising_edge(clk) then&#13;
            -- If CPU0 modifies a cache line, invalidate the corresponding line in CPU1&#13;
            if cpu0_state = "10" then -- Modified state in cpu0&#13;
                if cpu1_state = "01" and cpu0_addr = cpu1_addr then -- Shared state in cpu1 for the same address&#13;
                    invalidate_cpu1 &lt;= '1'; -- Invalidate the cache line in cpu1&#13;
                else&#13;
                    invalidate_cpu1 &lt;= '0';&#13;
                end if;&#13;
            end if;&#13;
            &#13;
            -- If CPU1 modifies a cache line, invalidate the corresponding line in CPU0&#13;
            if cpu1_state = "10" then -- Modified state in cpu1&#13;
                if cpu0_state = "01" and cpu1_addr = cpu0_addr then -- Shared state in cpu0 for the same address&#13;
                    invalidate_cpu0 &lt;= '1'; -- Invalidate the cache line in cpu0&#13;
                else&#13;
                    invalidate_cpu0 &lt;= '0';&#13;
                end if;&#13;
            end if;&#13;
        end if;&#13;
    end process;&#13;
end Behavioral;&#13;</vhdl>
  <vhdl name="FIFO">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity FIFO is
  port(
    clk            : in  std_logic;	-- system clock
    rst            : in  std_logic;	-- synchronous reset

    -- CPU0 interface
    cpu0_read_in   : in  std_logic;					-- CPU0 read request (1 = read)
    cpu0_write_in  : in  std_logic;					-- CPU0 write request (1 = write)
    cpu0_data_in   : in  std_logic_vector(31 downto 0);	-- CPU0 write data
    cpu0_addr      : in  std_logic_vector(2 downto 0);	-- CPU0 address

    -- CPU1 interface
    cpu1_read_in   : in  std_logic;
    cpu1_write_in  : in  std_logic;
    cpu1_data_in   : in  std_logic_vector(31 downto 0);
    cpu1_addr      : in  std_logic_vector(2 downto 0);

    -- Output to SDRAM
    read_out       : out std_logic;	-- 1 = perform read
    write_out      : out std_logic;	-- 1 = perform write

    addr_out       : out std_logic_vector(2 downto 0);	-- address to SDRAM
    data_out       : out std_logic_vector(31 downto 0)	-- data to SDRAM (for writes)
  );
end entity FIFO;

architecture behavior of FIFO is
  -- record and array _types_
  type sdramrequest is record
    requester : std_logic;			-- '0' = CPU0, '1' = CPU1
    operation : std_logic;            	-- 0 = read, 1 = write
    address   : std_logic_vector(2 downto 0);
    data      : std_logic_vector(31 downto 0);
    valid     : std_logic;
  end record sdramrequest;

  -- circular buffer of 1024 requests
  type sdramRequestBuffer is array(0 to 1023) of sdramrequest;

  -- allocate the buffer signal 
  signal request_buf : sdramRequestBuffer := (
    others =&gt; (
      requester =&gt; '0',
      operation =&gt; '0',
      address   =&gt; (others =&gt; '0'),
      data      =&gt; (others =&gt; '0'),
      valid     =&gt; '0'
    )
  );

  -- track which CPU was last served 
  signal previousRequester : std_logic;  -- 0 is cpu0, 1 is cpu1

begin

  process(clk, rst)
  begin
    if rst = '1' then
    	 -- synchronous reset: clear buffer and outputs
      -- clear buffer on reset
      request_buf &lt;= (others =&gt; (
        requester =&gt; '0',
        operation =&gt; '0',
        address   =&gt; (others =&gt; '0'),
        data      =&gt; (others =&gt; '0'),
        valid     =&gt; '0'
      ));
      read_out  &lt;= '0';
      write_out &lt;= '0';
      previousRequester &lt;= '0';

    elsif rising_edge(clk) then

    	 -- if there’s a pending SDRAM request at buffer slot 0
      if request_buf(0).valid = '1' then
        -- dequeue slot 0
        read_out  &lt;= not request_buf(0).operation;
        write_out &lt;=     request_buf(0).operation;
        addr_out  &lt;=     request_buf(0).address;
        data_out  &lt;=     request_buf(0).data;

        -- once served, invalidate this slot
        request_buf(0).valid &lt;= '0';

      else
      -- buffer is empty → directly arbitrate between CPU0 &amp; CPU1

        -- 1) No requests from either CPU
        if cpu0_read_in='0' and cpu0_write_in='0'
           and cpu1_read_in='0' and cpu1_write_in='0' then

          read_out  &lt;= '0';
          write_out &lt;= '0';

        -- 2) CPU1 wants to write only
        elsif cpu0_read_in='0' and cpu0_write_in='0'
           and cpu1_read_in='0' and cpu1_write_in='1' then

          read_out          &lt;= '0';
          write_out         &lt;= '1';
          previousRequester &lt;= '1';

        -- 3) CPU1 wants to read only
        elsif cpu0_read_in='0' and cpu0_write_in='0'
           and cpu1_read_in='1' and cpu1_write_in='0' then

          read_out          &lt;= '1';
          write_out         &lt;= '0';
          previousRequester &lt;= '1';

        -- 4) CPU0 wants to write only
        elsif cpu0_read_in='0' and cpu0_write_in='1'
           and cpu1_read_in='0' and cpu1_write_in='0' then

          read_out          &lt;= '0';
          write_out         &lt;= '1';
          previousRequester &lt;= '0';

        -- 5) CPU0 wants to read only
        elsif cpu0_read_in='1' and cpu0_write_in='0'
           and cpu1_read_in='0' and cpu1_write_in='0' then

          read_out          &lt;= '1';
          write_out         &lt;= '0';
          previousRequester &lt;= '0';

        -- 6) Both CPUs want to read → enqueue CPU1’s read
        elsif cpu0_read_in='1' and cpu0_write_in='0'
           and cpu1_read_in='1' and cpu1_write_in='0' then

          read_out          &lt;= '1';
          write_out         &lt;= '0';
          previousRequester &lt;= '0';

          request_buf(0).requester &lt;= '1';        -- from CPU1
          request_buf(0).operation &lt;= '0';        -- read
          request_buf(0).address   &lt;= cpu1_addr;
          request_buf(0).valid     &lt;= '1';

        -- 7) CPU0 read &amp; CPU1 write → enqueue CPU1’s write
        elsif cpu0_read_in='1' and cpu0_write_in='0'
           and cpu1_read_in='0' and cpu1_write_in='1' then

          read_out          &lt;= '1';
          write_out         &lt;= '0';
          previousRequester &lt;= '0';

          request_buf(0).requester &lt;= '1';
          request_buf(0).operation &lt;= '1';        -- write
          request_buf(0).address   &lt;= cpu1_addr;
          request_buf(0).data      &lt;= cpu1_data_in;
          request_buf(0).valid     &lt;= '1';

        -- 8) CPU0 write &amp; CPU1 read → enqueue CPU1’s read
        elsif cpu0_read_in='0' and cpu0_write_in='1'
           and cpu1_read_in='1' and cpu1_write_in='0' then

          read_out          &lt;= '0';
          write_out         &lt;= '1';
          previousRequester &lt;= '0';

          request_buf(0).requester &lt;= '1';
          request_buf(0).operation &lt;= '0';        -- read
          request_buf(0).address   &lt;= cpu1_addr;
          request_buf(0).valid     &lt;= '1';

        -- 9) Both CPUs want to write → enqueue CPU1’s write
        elsif cpu0_read_in='0' and cpu0_write_in='1'
           and cpu1_read_in='0' and cpu1_write_in='1' then

          read_out          &lt;= '0';
          write_out         &lt;= '1';
          previousRequester &lt;= '0';

          request_buf(0).requester &lt;= '1';
          request_buf(0).operation &lt;= '1';
          request_buf(0).address   &lt;= cpu1_addr;
          request_buf(0).data      &lt;= cpu1_data_in;
          request_buf(0).valid     &lt;= '1';

        end if;
      end if;

    end if;
  end process;

end architecture behavior;
</vhdl>
  <vhdl name="TransactionsBetweenCPU">
library ieee;
use ieee.std_logic_1164.all;

LIBRARY work;

entity TransactionsBetweenCPU is
  port(
    clk             : in  std_logic;                    -- system clock
    rst             : in  std_logic;                    -- synchronous reset
    cpu0_prio       : in  std_logic;                    -- arbitration priority for CPU0
    cpu1_prio       : in  std_logic;                    -- arbitration priority for CPU1
    cpu0_wantedAddr : in  std_logic_vector(2 downto 0); -- CPU0 target address
    cpu1_wantedAddr : in  std_logic_vector(2 downto 0)  -- CPU1 target address
  );
end entity TransactionsBetweenCPU;

architecture bdf_type of TransactionsBetweenCPU is

  -- Cache controller component
  component Cache_Controller is
    port(
      clk                          : in  std_logic;
      reset                        : in  std_logic;
      priority                     : in  std_logic;
      cpu_wr_req_in                : in  std_logic;
      cpu_rd_req_in                : in  std_logic;
      cache_to_cache_resp_in_ready: in  std_logic;
      cache_to_cache_resp_in       : in  std_logic;
      cache_to_cache_req_in        : in  std_logic;
      cache_to_cache_req_address_in: in  std_logic_vector(2 downto 0);
      cache_to_cache_resp_in_data  : in  std_logic_vector(31 downto 0);
      cpu_req_addr_in              : in  std_logic_vector(2 downto 0);
      Sdram_data_in                : in  std_logic_vector(31 downto 0);
      wantedAddress                : in  std_logic_vector(2 downto 0);
      read_en                      : out std_logic;
      write_en                     : out std_logic;
      cpu_wr_req_out               : out std_logic;
      cpu_rd_req_out               : out std_logic;
      cache_to_cache_resp_out_ready: out std_logic;
      cache_to_cache_resp_out      : out std_logic;
      cache_to_cache_req_out       : out std_logic;
      cache_to_cache_req_address_out: out std_logic_vector(2 downto 0);
      cache_to_cache_resp_out_data : out std_logic_vector(31 downto 0);
      cpu_req_addr_out             : out std_logic_vector(2 downto 0);
      Sdram_addr                   : out std_logic_vector(2 downto 0);
      Sdram_data_out               : out std_logic_vector(31 downto 0)
    );
  end component;


  -- SDRAM component
  component sdram is
    port(
      clk        : in  std_logic;
      reset      : in  std_logic;
      operation1 : in  std_logic;                     -- 0=read, 1=write on port1
      operation2 : in  std_logic;                     -- 0=read, 1=write on port2
      ready1     : in  std_logic;                     -- handshake from CPU1
      ready2     : in  std_logic;                     -- handshake from CPU2
      addr1      : in  std_logic_vector(2 downto 0);
      addr2      : in  std_logic_vector(2 downto 0);
      data_in1   : in  std_logic_vector(31 downto 0); -- CPU→SDRAM data
      data_in2   : in  std_logic_vector(31 downto 0);
      data_out1  : out std_logic_vector(31 downto 0); -- SDRAM→CPU data
      data_out2  : out std_logic_vector(31 downto 0)
    );
  end component;

  -- Internal signals for cache‐to‐cache traffic
  signal cpu0_cache_to_cache_req              : std_logic;
  signal cpu0_cache_to_cache_req_addr         : std_logic_vector(2 downto 0);
  signal cpu0_cache_to_cache_resp_data        : std_logic_vector(31 downto 0);
  signal cpu0_cache_to_cache_response         : std_logic;
  signal cpu0_cache_to_cache_response_out_ready : std_logic;
  signal cpu0_wr_req_out                      : std_logic;
  signal cpu0_rd_req_out                      : std_logic;
  signal cpu0_req_addr_out                    : std_logic_vector(2 downto 0);

  signal cpu1_cache_to_cache_req              : std_logic;
  signal cpu1_cache_to_cache_req_addr         : std_logic_vector(2 downto 0);
  signal cpu1_cache_to_cache_resp_data        : std_logic_vector(31 downto 0);
  signal cpu1_cache_to_cache_response         : std_logic;
  signal cpu1_cache_to_cache_response_out_ready : std_logic;
  signal cpu1_wr_req_out                      : std_logic;
  signal cpu1_rd_req_out                      : std_logic;
  signal cpu1_req_addr_out                    : std_logic_vector(2 downto 0);

  -- Read/Write enable flags from each CPU
  signal r_en1  : std_logic;
  signal wr_en1 : std_logic;
  signal r_en2  : std_logic;
  signal wr_en2 : std_logic;

  -- Combined “ready” lines into SDRAM
  signal ready1_sig : std_logic;
  signal ready2_sig : std_logic;

  -- Address buses from CPU → SDRAM
  signal sdram_addr1 : std_logic_vector(2 downto 0);
  signal sdram_addr2 : std_logic_vector(2 downto 0);

  -- Data buses CPU → SDRAM
  signal sdram_data_out1 : std_logic_vector(31 downto 0);
  signal sdram_data_out2 : std_logic_vector(31 downto 0);

  -- Data buses SDRAM → CPU
  signal sdram_data_in1  : std_logic_vector(31 downto 0);
  signal sdram_data_in2  : std_logic_vector(31 downto 0);

begin

  -- Generate “ready” handshake for SDRAM ports
  ready1_sig &lt;= wr_en1 or r_en1;
  ready2_sig &lt;= wr_en2 or r_en2;

  -- CPU Core #0 instance
  core0: Cache_Controller
    port map(
      clk                            =&gt; clk,
      reset                          =&gt; rst,
      priority                       =&gt; cpu0_prio,
      cpu_wr_req_in                  =&gt; cpu1_wr_req_out,
      cpu_rd_req_in                  =&gt; cpu1_rd_req_out,
      cache_to_cache_resp_in_ready   =&gt; cpu1_cache_to_cache_response_out_ready,
      cache_to_cache_resp_in         =&gt; cpu1_cache_to_cache_response,
      cache_to_cache_req_in          =&gt; cpu1_cache_to_cache_req,
      cache_to_cache_req_address_in  =&gt; cpu1_cache_to_cache_req_addr,
      cache_to_cache_resp_in_data    =&gt; cpu1_cache_to_cache_resp_data,
      cpu_req_addr_in                =&gt; cpu1_req_addr_out,
      Sdram_data_in                  =&gt; sdram_data_in1,     -- from SDRAM
      wantedAddress                  =&gt; cpu0_wantedAddr,
      read_en                        =&gt; r_en1,
      write_en                       =&gt; wr_en1,
      cpu_wr_req_out                 =&gt; cpu0_wr_req_out,
      cpu_rd_req_out                 =&gt; cpu0_rd_req_out,
      cache_to_cache_resp_out_ready  =&gt; cpu0_cache_to_cache_response_out_ready,
      cache_to_cache_resp_out        =&gt; cpu0_cache_to_cache_response,
      cache_to_cache_req_out         =&gt; cpu0_cache_to_cache_req,
      cache_to_cache_req_address_out =&gt; cpu0_cache_to_cache_req_addr,
      cache_to_cache_resp_out_data   =&gt; cpu0_cache_to_cache_resp_data,
      cpu_req_addr_out               =&gt; cpu0_req_addr_out,
      Sdram_addr                     =&gt; sdram_addr1,         -- to SDRAM
      Sdram_data_out                 =&gt; sdram_data_out1      -- to SDRAM
    );

  -- CPU Core #1 instance
  core1: Cache_Controller
    port map(
      clk                            =&gt; clk,
      reset                          =&gt; rst,
      priority                       =&gt; cpu1_prio,
      cpu_wr_req_in                  =&gt; cpu0_wr_req_out,
      cpu_rd_req_in                  =&gt; cpu0_rd_req_out,
      cache_to_cache_resp_in_ready   =&gt; cpu0_cache_to_cache_response_out_ready,
      cache_to_cache_resp_in         =&gt; cpu0_cache_to_cache_response,
      cache_to_cache_req_in          =&gt; cpu0_cache_to_cache_req,
      cache_to_cache_req_address_in  =&gt; cpu0_cache_to_cache_req_addr,
      cache_to_cache_resp_in_data    =&gt; cpu0_cache_to_cache_resp_data,
      cpu_req_addr_in                =&gt; cpu0_req_addr_out,
      Sdram_data_in                  =&gt; sdram_data_in2,     -- from SDRAM
      wantedAddress                  =&gt; cpu1_wantedAddr,
      read_en                        =&gt; r_en2,
      write_en                       =&gt; wr_en2,
      cpu_wr_req_out                 =&gt; cpu1_wr_req_out,
      cpu_rd_req_out                 =&gt; cpu1_rd_req_out,
      cache_to_cache_resp_out_ready  =&gt; cpu1_cache_to_cache_response_out_ready,
      cache_to_cache_resp_out        =&gt; cpu1_cache_to_cache_response,
      cache_to_cache_req_out         =&gt; cpu1_cache_to_cache_req,
      cache_to_cache_req_address_out =&gt; cpu1_cache_to_cache_req_addr,
      cache_to_cache_resp_out_data   =&gt; cpu1_cache_to_cache_resp_data,
      cpu_req_addr_out               =&gt; cpu1_req_addr_out,
      Sdram_addr                     =&gt; sdram_addr2,         -- to SDRAM
      Sdram_data_out                 =&gt; sdram_data_out2      -- to SDRAM
    );

  -- SDRAM instance (port‐interleaved two‐port memory)
  sdram0: sdram
    port map(
      clk        =&gt; clk,
      reset      =&gt; rst,
      operation1 =&gt; wr_en1,           -- write when wr_en1='1'
      operation2 =&gt; wr_en2,           -- write when wr_en2='1'
      ready1     =&gt; ready1_sig,
      ready2     =&gt; ready2_sig,
      addr1      =&gt; sdram_addr1,
      addr2      =&gt; sdram_addr2,
      data_in1   =&gt; sdram_data_out1,  -- CPU0 → SDRAM
      data_in2   =&gt; sdram_data_out2,  -- CPU1 → SDRAM
      data_out1  =&gt; sdram_data_in1,   -- SDRAM → CPU0
      data_out2  =&gt; sdram_data_in2    -- SDRAM → CPU1
    );

end architecture bdf_type;
</vhdl>
  <vhdl name="Cache_Controller">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity Cache_Controller is
    port (
        clk            : in std_logic;
        reset          : in std_logic;
        priority       : in std_logic;
        
        -- CPU interface
        wantedAddress  : in std_logic_vector(2 downto 0);
        
        -- SDRAM interface
        read_en        : out std_logic;
        write_en       : out std_logic;
        Sdram_addr     : out std_logic_vector(2 downto 0);
        Sdram_data_in  : in std_logic_vector(31 downto 0);
        Sdram_data_out : out std_logic_vector(31 downto 0);
        
        -- MSI protocol - outgoing requests
        cpu_wr_req_out : out std_logic;
        cpu_rd_req_out : out std_logic;
        cpu_req_addr_out : out std_logic_vector(2 downto 0);
        
        -- MSI protocol - incoming requests (snooping)
        cpu_wr_req_in  : in std_logic;
        cpu_rd_req_in  : in std_logic;
        cpu_req_addr_in : in std_logic_vector(2 downto 0);
        
        -- Cache-to-cache communication - outgoing
        cache_to_cache_req_out : out std_logic;
        cache_to_cache_req_address_out : out std_logic_vector(2 downto 0);
        cache_to_cache_resp_out : out std_logic;
        cache_to_cache_resp_out_ready : out std_logic;
        cache_to_cache_resp_out_data : out std_logic_vector(31 downto 0);
        
        -- Cache-to-cache communication - incoming
        cache_to_cache_req_in : in std_logic;
        cache_to_cache_req_address_in : in std_logic_vector(2 downto 0);
        cache_to_cache_resp_in : in std_logic;
        cache_to_cache_resp_in_ready : in std_logic;
        cache_to_cache_resp_in_data : in std_logic_vector(31 downto 0);
        
        -- DEBUG OUTPUTS - Estado del controlador de cache
        debug_cpu_state      : out std_logic_vector(2 downto 0);    -- Estado de la CPU (idle/read/write/wait)
        debug_cache_state    : out std_logic_vector(2 downto 0);    -- Estado de la cache (check/hit/miss/coherence/sdram)
        debug_cache_hit      : out std_logic;                       -- Señal de cache hit
        debug_current_addr   : out std_logic_vector(2 downto 0);    -- Dirección actual siendo procesada
        debug_operation_type : out std_logic;                       -- Tipo de operación (0=read, 1=write)
        debug_evict_index    : out std_logic_vector(1 downto 0);    -- Índice de evicción actual
        debug_cycle_counter  : out std_logic_vector(3 downto 0);    -- Contador de ciclos
        
        -- DEBUG OUTPUTS - Estado de las líneas de cache
        debug_cache_line0_valid : out std_logic;                    -- Línea 0 válida
        debug_cache_line0_state : out std_logic_vector(1 downto 0); -- Estado MSI línea 0 (00=Invalid, 01=Shared, 10=Modified)
        debug_cache_line0_addr  : out std_logic_vector(2 downto 0); -- Dirección línea 0
        debug_cache_line0_data  : out std_logic_vector(31 downto 0);-- Datos línea 0
        
        debug_cache_line1_valid : out std_logic;                    -- Línea 1 válida
        debug_cache_line1_state : out std_logic_vector(1 downto 0); -- Estado MSI línea 1
        debug_cache_line1_addr  : out std_logic_vector(2 downto 0); -- Dirección línea 1
        debug_cache_line1_data  : out std_logic_vector(31 downto 0);-- Datos línea 1
        
        debug_cache_line2_valid : out std_logic;                    -- Línea 2 válida
        debug_cache_line2_state : out std_logic_vector(1 downto 0); -- Estado MSI línea 2
        debug_cache_line2_addr  : out std_logic_vector(2 downto 0); -- Dirección línea 2
        debug_cache_line2_data  : out std_logic_vector(31 downto 0);-- Datos línea 2
        
        debug_cache_line3_valid : out std_logic;                    -- Línea 3 válida
        debug_cache_line3_state : out std_logic_vector(1 downto 0); -- Estado MSI línea 3
        debug_cache_line3_addr  : out std_logic_vector(2 downto 0); -- Dirección línea 3
        debug_cache_line3_data  : out std_logic_vector(31 downto 0) -- Datos línea 3
    );
end Cache_Controller;

architecture Behavioral of Cache_Controller is
    -- Cache configuration
    constant CACHE_SIZE : integer := 4;
    
    -- MSI states
    type msi_state_type is (MSI_INVALID, MSI_SHARED, MSI_MODIFIED);
    
    -- Cache line structure
    type cache_line_type is record
        msi_state : msi_state_type;
        address   : std_logic_vector(2 downto 0);
        data      : std_logic_vector(31 downto 0);
        valid     : std_logic;
    end record;
    
    type cache_array_type is array (0 to CACHE_SIZE-1) of cache_line_type;
    
    -- CPU operation states
    type cpu_state_type is (CPU_IDLE, CPU_READ, CPU_WRITE, CPU_WAIT_CACHE, CPU_WAIT_SDRAM);
    
    -- Cache operation states  
    type cache_state_type is (CACHE_CHECK, CACHE_HIT, CACHE_MISS, CACHE_COHERENCE, CACHE_SDRAM_ACCESS);
    
    -- Signals
    signal cache_mem : cache_array_type;
    signal cpu_state : cpu_state_type;
    signal cache_state : cache_state_type;
    signal current_address : std_logic_vector(2 downto 0);
    signal current_data : std_logic_vector(31 downto 0);
    signal cache_hit_flag : std_logic;
    signal cache_hit_index : integer range 0 to CACHE_SIZE-1;
    signal evict_index : integer range 0 to CACHE_SIZE-1;
    signal operation_type : std_logic; -- 0 = read, 1 = write
    signal cycle_counter : integer range 0 to 15;
    
    -- Helper functions
    function find_cache_line(addr : std_logic_vector(2 downto 0); cache_mem : cache_array_type) 
        return integer is
    begin
        for i in 0 to CACHE_SIZE-1 loop
            if cache_mem(i).valid = '1' and cache_mem(i).address = addr then
                return i;
            end if;
        end loop;
        return -1; -- Not found
    end function;
    
    function find_empty_line(cache_mem : cache_array_type) return integer is
    begin
        for i in 0 to CACHE_SIZE-1 loop
            if cache_mem(i).valid = '0' then
                return i;
            end if;
        end loop;
        return -1; -- Cache full
    end function;

begin

    -- Asignaciones continuas para señales de debug
    debug_current_addr &lt;= current_address;
    debug_operation_type &lt;= operation_type;
    debug_cache_hit &lt;= cache_hit_flag;
    debug_evict_index &lt;= std_logic_vector(to_unsigned(evict_index, 2));
    debug_cycle_counter &lt;= std_logic_vector(to_unsigned(cycle_counter, 4));
    
    -- Codificación de estados de CPU para debug
    with cpu_state select debug_cpu_state &lt;=
        "000" when CPU_IDLE,
        "001" when CPU_READ,
        "010" when CPU_WRITE,
        "011" when CPU_WAIT_CACHE,
        "100" when CPU_WAIT_SDRAM,
        "111" when others;
    
    -- Codificación de estados de cache para debug
    with cache_state select debug_cache_state &lt;=
        "000" when CACHE_CHECK,
        "001" when CACHE_HIT,
        "010" when CACHE_MISS,
        "011" when CACHE_COHERENCE,
        "100" when CACHE_SDRAM_ACCESS,
        "111" when others;
    
    -- Debug outputs para líneas de cache (línea 0)
    debug_cache_line0_valid &lt;= cache_mem(0).valid;
    debug_cache_line0_addr &lt;= cache_mem(0).address;
    debug_cache_line0_data &lt;= cache_mem(0).data;
    with cache_mem(0).msi_state select debug_cache_line0_state &lt;=
        "00" when MSI_INVALID,
        "01" when MSI_SHARED,
        "10" when MSI_MODIFIED,
        "11" when others;
    
    -- Debug outputs para líneas de cache (línea 1)
    debug_cache_line1_valid &lt;= cache_mem(1).valid;
    debug_cache_line1_addr &lt;= cache_mem(1).address;
    debug_cache_line1_data &lt;= cache_mem(1).data;
    with cache_mem(1).msi_state select debug_cache_line1_state &lt;=
        "00" when MSI_INVALID,
        "01" when MSI_SHARED,
        "10" when MSI_MODIFIED,
        "11" when others;
    
    -- Debug outputs para líneas de cache (línea 2)
    debug_cache_line2_valid &lt;= cache_mem(2).valid;
    debug_cache_line2_addr &lt;= cache_mem(2).address;
    debug_cache_line2_data &lt;= cache_mem(2).data;
    with cache_mem(2).msi_state select debug_cache_line2_state &lt;=
        "00" when MSI_INVALID,
        "01" when MSI_SHARED,
        "10" when MSI_MODIFIED,
        "11" when others;
    
    -- Debug outputs para líneas de cache (línea 3)
    debug_cache_line3_valid &lt;= cache_mem(3).valid;
    debug_cache_line3_addr &lt;= cache_mem(3).address;
    debug_cache_line3_data &lt;= cache_mem(3).data;
    with cache_mem(3).msi_state select debug_cache_line3_state &lt;=
        "00" when MSI_INVALID,
        "01" when MSI_SHARED,
        "10" when MSI_MODIFIED,
        "11" when others;

    -- Main cache controller process
    main_process: process(clk, reset)
        variable hit_index : integer;
        variable empty_index : integer;
    begin
        if reset = '1' then
            -- Initialize cache
            for i in 0 to CACHE_SIZE-1 loop
                cache_mem(i).msi_state &lt;= MSI_INVALID;
                cache_mem(i).address &lt;= (others =&gt; '0');
                cache_mem(i).data &lt;= (others =&gt; '0');
                cache_mem(i).valid &lt;= '0';
            end loop;
            
            -- Reset state machines
            cpu_state &lt;= CPU_IDLE;
            cache_state &lt;= CACHE_CHECK;
            
            -- Reset outputs
            read_en &lt;= '0';
            write_en &lt;= '0';
            cpu_wr_req_out &lt;= '0';
            cpu_rd_req_out &lt;= '0';
            cache_to_cache_req_out &lt;= '0';
            cache_to_cache_resp_out &lt;= '0';
            cache_to_cache_resp_out_ready &lt;= '0';
            
            -- Reset internal signals
            current_address &lt;= (others =&gt; '0');
            current_data &lt;= (others =&gt; '0');
            cache_hit_flag &lt;= '0';
            cache_hit_index &lt;= 0;
            operation_type &lt;= '0';
            evict_index &lt;= 0;
            cycle_counter &lt;= 0;
            
        elsif rising_edge(clk) then
            -- Default signal values
            read_en &lt;= '0';
            write_en &lt;= '0';
            cache_to_cache_req_out &lt;= '0';
            cache_to_cache_resp_out &lt;= '0';
            cache_to_cache_resp_out_ready &lt;= '0';
            
            -- Handle snooping requests from other caches
            if cache_to_cache_req_in = '1' then
                hit_index := find_cache_line(cache_to_cache_req_address_in, cache_mem);
                if hit_index &gt;= 0 then
                    if cache_mem(hit_index).msi_state = MSI_MODIFIED then
                        -- Provide data and transition to shared
                        cache_to_cache_resp_out &lt;= '1';
                        cache_to_cache_resp_out_data &lt;= cache_mem(hit_index).data;
                        cache_mem(hit_index).msi_state &lt;= MSI_SHARED;
                    elsif cache_mem(hit_index).msi_state = MSI_SHARED then
                        -- Provide data, stay shared
                        cache_to_cache_resp_out &lt;= '1';
                        cache_to_cache_resp_out_data &lt;= cache_mem(hit_index).data;
                    end if;
                else
                    cache_to_cache_resp_out &lt;= '0';
                end if;
                cache_to_cache_resp_out_ready &lt;= '1';
            end if;
            
            -- Handle invalidation requests
            if cpu_wr_req_in = '1' then
                hit_index := find_cache_line(cpu_req_addr_in, cache_mem);
                if hit_index &gt;= 0 then
                    cache_mem(hit_index).msi_state &lt;= MSI_INVALID;
                    cache_mem(hit_index).valid &lt;= '0';
                end if;
            end if;
            
            -- Main CPU state machine
            case cpu_state is
                when CPU_IDLE =&gt;
                    cycle_counter &lt;= cycle_counter + 1;
                    
                    -- Simple test pattern - MODIFIED FOR READ TEST
                    if cycle_counter = 3 then
                        cpu_state &lt;= CPU_READ;
                        current_address &lt;= wantedAddress;
                        operation_type &lt;= '0'; -- read
                        cpu_rd_req_out &lt;= '1';
                        cpu_req_addr_out &lt;= wantedAddress;
                        cache_state &lt;= CACHE_CHECK;
                        cycle_counter &lt;= 0;
                    elsif cycle_counter = 8 then
                        cpu_state &lt;= CPU_WRITE;
                        current_address &lt;= wantedAddress;
                        current_data &lt;= x"DEADBEEF";
                        operation_type &lt;= '1'; -- write
                        cpu_wr_req_out &lt;= '1';
                        cpu_req_addr_out &lt;= wantedAddress;
                        cache_state &lt;= CACHE_CHECK;
                        cycle_counter &lt;= 0;
                    end if;
                
                when CPU_READ | CPU_WRITE =&gt;
                    case cache_state is
                        when CACHE_CHECK =&gt;
                            hit_index := find_cache_line(current_address, cache_mem);
                            if hit_index &gt;= 0 and cache_mem(hit_index).msi_state /= MSI_INVALID then
                                -- Cache hit
                                cache_hit_flag &lt;= '1';
                                cache_hit_index &lt;= hit_index;
                                cache_state &lt;= CACHE_HIT;
                            else
                                -- Cache miss
                                cache_hit_flag &lt;= '0';
                                cache_state &lt;= CACHE_MISS;
                            end if;
                        
                        when CACHE_HIT =&gt;
                            if operation_type = '0' then
                                -- Read hit - return data
                                cpu_state &lt;= CPU_IDLE;
                                cpu_rd_req_out &lt;= '0';
                                cache_state &lt;= CACHE_CHECK;
                            else
                                -- Write hit - update data and set modified
                                cache_mem(cache_hit_index).data &lt;= current_data;
                                cache_mem(cache_hit_index).msi_state &lt;= MSI_MODIFIED;
                                cpu_state &lt;= CPU_IDLE;
                                cpu_wr_req_out &lt;= '0';
                                cache_state &lt;= CACHE_CHECK;
                            end if;
                        
                        when CACHE_MISS =&gt;
                            -- Try cache-to-cache transfer first
                            cache_to_cache_req_out &lt;= '1';
                            cache_to_cache_req_address_out &lt;= current_address;
                            cache_state &lt;= CACHE_COHERENCE;
                        
                        when CACHE_COHERENCE =&gt;
                            if cache_to_cache_resp_in_ready = '1' then
                                if cache_to_cache_resp_in = '1' then
                                    -- Cache-to-cache hit
                                    empty_index := find_empty_line(cache_mem);
                                    if empty_index &gt;= 0 then
                                        -- Use empty line
                                        cache_mem(empty_index).valid &lt;= '1';
                                        cache_mem(empty_index).address &lt;= current_address;
                                        cache_mem(empty_index).data &lt;= cache_to_cache_resp_in_data;
                                        if operation_type = '0' then
                                            cache_mem(empty_index).msi_state &lt;= MSI_SHARED;
                                        else
                                            cache_mem(empty_index).msi_state &lt;= MSI_MODIFIED;
                                            cache_mem(empty_index).data &lt;= current_data;
                                        end if;
                                    else
                                        -- Evict using round-robin
                                        if cache_mem(evict_index).msi_state = MSI_MODIFIED then
                                            -- Write back to SDRAM
                                            write_en &lt;= '1';
                                            Sdram_addr &lt;= cache_mem(evict_index).address;
                                            Sdram_data_out &lt;= cache_mem(evict_index).data;
                                        end if;
                                        cache_mem(evict_index).valid &lt;= '1';
                                        cache_mem(evict_index).address &lt;= current_address;
                                        cache_mem(evict_index).data &lt;= cache_to_cache_resp_in_data;
                                        if operation_type = '0' then
                                            cache_mem(evict_index).msi_state &lt;= MSI_SHARED;
                                        else
                                            cache_mem(evict_index).msi_state &lt;= MSI_MODIFIED;
                                            cache_mem(evict_index).data &lt;= current_data;
                                        end if;
                                        evict_index &lt;= (evict_index + 1) mod CACHE_SIZE;
                                    end if;
                                    cpu_state &lt;= CPU_IDLE;
                                    if operation_type = '0' then
                                        cpu_rd_req_out &lt;= '0';
                                    else
                                        cpu_wr_req_out &lt;= '0';
                                    end if;
                                    cache_state &lt;= CACHE_CHECK;
                                else
                                    -- Cache-to-cache miss, go to SDRAM
                                    cache_state &lt;= CACHE_SDRAM_ACCESS;
                                end if;
                            end if;
                        
                        when CACHE_SDRAM_ACCESS =&gt;
                            if operation_type = '0' then
                                read_en &lt;= '1';
                            else
                                write_en &lt;= '1';
                                Sdram_data_out &lt;= current_data;
                            end if;
                            Sdram_addr &lt;= current_address;
                            
                            -- Allocate cache line
                            empty_index := find_empty_line(cache_mem);
                            if empty_index &gt;= 0 then
                                cache_mem(empty_index).valid &lt;= '1';
                                cache_mem(empty_index).address &lt;= current_address;
                                if operation_type = '0' then
                                    cache_mem(empty_index).data &lt;= Sdram_data_in;
                                    cache_mem(empty_index).msi_state &lt;= MSI_SHARED;
                                else
                                    cache_mem(empty_index).data &lt;= current_data;
                                    cache_mem(empty_index).msi_state &lt;= MSI_MODIFIED;
                                end if;
                            else
                                -- Evict using round-robin
                                if cache_mem(evict_index).msi_state = MSI_MODIFIED then
                                    write_en &lt;= '1';
                                    Sdram_addr &lt;= cache_mem(evict_index).address;
                                    Sdram_data_out &lt;= cache_mem(evict_index).data;
                                end if;
                                cache_mem(evict_index).valid &lt;= '1';
                                cache_mem(evict_index).address &lt;= current_address;
                                if operation_type = '0' then
                                    cache_mem(evict_index).data &lt;= Sdram_data_in;
                                    cache_mem(evict_index).msi_state &lt;= MSI_SHARED;
                                else
                                    cache_mem(evict_index).data &lt;= current_data;
                                    cache_mem(evict_index).msi_state &lt;= MSI_MODIFIED;
                                end if;
                                evict_index &lt;= (evict_index + 1) mod CACHE_SIZE;
                            end if;
                            
                            cpu_state &lt;= CPU_IDLE;
                            if operation_type = '0' then
                                cpu_rd_req_out &lt;= '0';
                            else
                                cpu_wr_req_out &lt;= '0';
                            end if;
                            cache_state &lt;= CACHE_CHECK;
                    end case;
                
                when others =&gt;
                    cpu_state &lt;= CPU_IDLE;
            end case;
        end if;
    end process;

end Behavioral;
</vhdl>
  <vhdl name="sdram">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity sdram is
    port(
        clk        : in  std_logic;
        reset      : in  std_logic;
        operation1 : in  std_logic;                     -- 0=read, 1=write on port1
        operation2 : in  std_logic;                     -- 0=read, 1=write on port2
        ready1     : in  std_logic;                     -- handshake from CPU1
        ready2     : in  std_logic;                     -- handshake from CPU2
        addr1      : in  std_logic_vector(2 downto 0);
        addr2      : in  std_logic_vector(2 downto 0);
        data_in1   : in  std_logic_vector(31 downto 0); -- CPU→SDRAM data
        data_in2   : in  std_logic_vector(31 downto 0);
        data_out1  : out std_logic_vector(31 downto 0); -- SDRAM→CPU data
        data_out2  : out std_logic_vector(31 downto 0)
    );
end sdram;

architecture Behavioral of sdram is
    type memory_array is array (0 to 7) of std_logic_vector(31 downto 0);
    signal memory : memory_array;
begin
    process(clk, reset)
    begin
        if reset = '1' then
            -- Initialize memory with test pattern
            memory(0) &lt;= x"00000000";
            memory(1) &lt;= x"11111111";
            memory(2) &lt;= x"22222222";
            memory(3) &lt;= x"33333333";
            memory(4) &lt;= x"44444444";
            memory(5) &lt;= x"55555555";
            memory(6) &lt;= x"66666666";
            memory(7) &lt;= x"77777777";
        elsif rising_edge(clk) then
            -- Port 1 operations
            if ready1 = '1' then
                if operation1 = '1' then
                    -- Write
                    memory(to_integer(unsigned(addr1))) &lt;= data_in1;
                else
                    -- Read
                    data_out1 &lt;= memory(to_integer(unsigned(addr1)));
                end if;
            end if;
            
            -- Port 2 operations
            if ready2 = '1' then
                if operation2 = '1' then
                    -- Write
                    memory(to_integer(unsigned(addr2))) &lt;= data_in2;
                else
                    -- Read
                    data_out2 &lt;= memory(to_integer(unsigned(addr2)));
                end if;
            end if;
        end if;
    end process;
end Behavioral;
</vhdl>
</project>
