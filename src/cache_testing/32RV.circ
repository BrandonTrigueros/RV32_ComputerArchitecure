<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project source="3.9.0" version="1.0">
  This file is intended to be loaded by Logisim-evolution v3.9.0(https://github.com/logisim-evolution/).

  <lib desc="#Wiring" name="0">
    <tool name="Pin">
      <a name="appearance" val="classic"/>
    </tool>
    <tool name="Tunnel">
      <a name="labelfont" val="SansSerif bold 10"/>
    </tool>
    <tool name="Constant">
      <a name="facing" val="west"/>
      <a name="value" val="0x0"/>
    </tool>
  </lib>
  <lib desc="#Gates" name="1"/>
  <lib desc="#Plexers" name="2"/>
  <lib desc="#Arithmetic" name="3"/>
  <lib desc="#Memory" name="4"/>
  <lib desc="#I/O" name="5"/>
  <lib desc="#TTL" name="6"/>
  <lib desc="#TCL" name="7"/>
  <lib desc="#Base" name="8"/>
  <lib desc="#BFH-Praktika" name="9"/>
  <lib desc="#Input/Output-Extra" name="10"/>
  <lib desc="#Soc" name="11"/>
  <main name="cache_system"/>
  <options>
    <a name="gateUndefined" val="ignore"/>
    <a name="simlimit" val="1000"/>
    <a name="simrand" val="0"/>
  </options>
  <mappings>
    <tool lib="8" map="Button2" name="Poke Tool"/>
    <tool lib="8" map="Button3" name="Menu Tool"/>
    <tool lib="8" map="Ctrl Button1" name="Menu Tool"/>
  </mappings>
  <toolbar>
    <tool lib="8" name="Poke Tool"/>
    <tool lib="8" name="Edit Tool"/>
    <tool lib="8" name="Wiring Tool"/>
    <tool lib="8" name="Text Tool"/>
    <sep/>
    <tool lib="0" name="Pin"/>
    <tool lib="0" name="Pin">
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
    </tool>
    <sep/>
    <tool lib="1" name="NOT Gate"/>
    <tool lib="1" name="AND Gate"/>
    <tool lib="1" name="OR Gate"/>
    <tool lib="1" name="XOR Gate"/>
    <tool lib="1" name="NAND Gate"/>
    <tool lib="1" name="NOR Gate"/>
    <sep/>
    <tool lib="4" name="D Flip-Flop"/>
    <tool lib="4" name="Register"/>
  </toolbar>
  <circuit name="cache_system">
    <a name="appearance" val="logisim_evolution"/>
    <a name="circuit" val="cache_system"/>
    <a name="circuitnamedboxfixedsize" val="true"/>
    <a name="simulationFrequency" val="1.0"/>
    <comp lib="0" loc="(540,370)" name="Clock"/>
    <comp lib="0" loc="(540,390)" name="Pin">
      <a name="appearance" val="classic"/>
    </comp>
    <comp lib="0" loc="(540,410)" name="Constant"/>
    <comp lib="0" loc="(540,430)" name="Constant">
      <a name="value" val="0x0"/>
    </comp>
    <comp lib="0" loc="(540,450)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(540,470)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(540,490)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(540,510)" name="Pin">
      <a name="appearance" val="classic"/>
    </comp>
    <comp lib="0" loc="(540,530)" name="Pin">
      <a name="appearance" val="classic"/>
    </comp>
    <comp lib="0" loc="(540,550)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(540,570)" name="Pin">
      <a name="appearance" val="classic"/>
    </comp>
    <comp lib="0" loc="(540,590)" name="Pin">
      <a name="appearance" val="classic"/>
    </comp>
    <comp lib="0" loc="(800,370)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(800,410)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
      <a name="radix" val="16"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(800,450)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(800,470)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(800,490)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="0" loc="(800,510)" name="Pin">
      <a name="appearance" val="classic"/>
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
      <a name="width" val="3"/>
    </comp>
    <comp lib="5" loc="(800,390)" name="LED"/>
    <comp lib="5" loc="(800,430)" name="LED"/>
    <comp lib="5" loc="(800,530)" name="LED"/>
    <comp lib="5" loc="(800,550)" name="LED"/>
    <comp lib="5" loc="(800,570)" name="LED"/>
    <comp lib="5" loc="(800,590)" name="LED"/>
    <comp loc="(780,370)" name="TransactionsBetweenCPU">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <wire from="(540,370)" to="(560,370)"/>
    <wire from="(540,390)" to="(560,390)"/>
    <wire from="(540,410)" to="(560,410)"/>
    <wire from="(540,430)" to="(560,430)"/>
    <wire from="(540,450)" to="(560,450)"/>
    <wire from="(540,470)" to="(560,470)"/>
    <wire from="(540,490)" to="(560,490)"/>
    <wire from="(540,510)" to="(560,510)"/>
    <wire from="(540,530)" to="(560,530)"/>
    <wire from="(540,550)" to="(560,550)"/>
    <wire from="(540,570)" to="(560,570)"/>
    <wire from="(540,590)" to="(560,590)"/>
    <wire from="(780,370)" to="(800,370)"/>
    <wire from="(780,390)" to="(800,390)"/>
    <wire from="(780,410)" to="(800,410)"/>
    <wire from="(780,430)" to="(800,430)"/>
    <wire from="(780,450)" to="(800,450)"/>
    <wire from="(780,470)" to="(800,470)"/>
    <wire from="(780,490)" to="(800,490)"/>
    <wire from="(780,510)" to="(800,510)"/>
    <wire from="(780,530)" to="(800,530)"/>
    <wire from="(780,550)" to="(800,550)"/>
    <wire from="(780,570)" to="(800,570)"/>
    <wire from="(780,590)" to="(800,590)"/>
  </circuit>
  <vhdl name="TransactionsBetweenCPU">
library ieee;
use ieee.std_logic_1164.all;

LIBRARY work;

entity TransactionsBetweenCPU is
  port(
    clk             : in  std_logic;                    -- system clock
    rst             : in  std_logic;                    -- synchronous reset
    cpu0_prio       : in  std_logic;                    -- arbitration priority for CPU0
    cpu1_prio       : in  std_logic;                    -- arbitration priority for CPU1
    cpu0_wantedAddr : in  std_logic_vector(2 downto 0); -- CPU0 target address
    cpu1_wantedAddr : in  std_logic_vector(2 downto 0); -- CPU1 target address
    
    -- CPU0 interface signals
    cpu0_data_in    : in  std_logic_vector(31 downto 0); -- CPU0 data for write
    cpu0_data_out   : out std_logic_vector(31 downto 0); -- CPU0 data read
    cpu0_req        : in  std_logic;                     -- CPU0 request
    cpu0_rw         : in  std_logic;                     -- CPU0 read/write
    cpu0_ready      : out std_logic;                     -- CPU0 operation complete
    
    -- CPU1 interface signals
    cpu1_data_in    : in  std_logic_vector(31 downto 0); -- CPU1 data for write
    cpu1_data_out   : out std_logic_vector(31 downto 0); -- CPU1 data read
    cpu1_req        : in  std_logic;                     -- CPU1 request
    cpu1_rw         : in  std_logic;                     -- CPU1 read/write
    cpu1_ready      : out std_logic;                     -- CPU1 operation complete
    
    -- DEBUG OUTPUTS
    debug_cpu0_state     : out std_logic_vector(2 downto 0); -- CPU0 state for debug
    debug_cpu1_state     : out std_logic_vector(2 downto 0); -- CPU1 state for debug
    debug_cache0_state   : out std_logic_vector(2 downto 0); -- Cache0 state for debug
    debug_cache1_state   : out std_logic_vector(2 downto 0); -- Cache1 state for debug
    debug_sdram_ready    : out std_logic;                    -- SDRAM ready flag
    debug_cpu0_hit       : out std_logic;                    -- CPU0 cache hit
    debug_cpu1_hit       : out std_logic;                    -- CPU1 cache hit
    debug_reset_active   : out std_logic                     -- Reset status
  );
end entity TransactionsBetweenCPU;

architecture bdf_type of TransactionsBetweenCPU is

  -- Cache controller component
  component Cache_Controller is
    port(
      clk                          : in  std_logic;
      reset                        : in  std_logic;
      priority                     : in  std_logic;
      -- CPU interface signals
      wantedAddress                : in  std_logic_vector(2 downto 0);
      cpu_data_in                  : in  std_logic_vector(31 downto 0);
      cpu_data_out                 : out std_logic_vector(31 downto 0);
      cpu_req                      : in  std_logic;
      cpu_rw                       : in  std_logic;
      cpu_ready                    : out std_logic;
      -- SDRAM interface
      read_en                      : out std_logic;
      write_en                     : out std_logic;
      Sdram_addr                   : out std_logic_vector(2 downto 0);
      Sdram_data_in                : in  std_logic_vector(31 downto 0);
      Sdram_data_out               : out std_logic_vector(31 downto 0);
      -- MSI protocol signals
      cpu_wr_req_in                : in  std_logic;
      cpu_rd_req_in                : in  std_logic;
      cache_to_cache_resp_in_ready : in  std_logic;
      cache_to_cache_resp_in       : in  std_logic;
      cache_to_cache_req_in        : in  std_logic;
      cache_to_cache_req_address_in: in  std_logic_vector(2 downto 0);
      cache_to_cache_resp_in_data  : in  std_logic_vector(31 downto 0);
      cpu_req_addr_in              : in  std_logic_vector(2 downto 0);
      cpu_wr_req_out               : out std_logic;
      cpu_rd_req_out               : out std_logic;
      cache_to_cache_resp_out_ready: out std_logic;
      cache_to_cache_resp_out      : out std_logic;
      cache_to_cache_req_out       : out std_logic;
      cache_to_cache_req_address_out: out std_logic_vector(2 downto 0);
      cache_to_cache_resp_out_data : out std_logic_vector(31 downto 0);
      cpu_req_addr_out             : out std_logic_vector(2 downto 0);
      -- DEBUG OUTPUTS
      debug_cpu_state              : out std_logic_vector(2 downto 0);
      debug_cache_state            : out std_logic_vector(2 downto 0);
      debug_cache_hit              : out std_logic
    );
  end component;


  -- SDRAM component
  component sdram is
    port(
      clk        : in  std_logic;
      reset      : in  std_logic;
      operation1 : in  std_logic;                     -- 0=read, 1=write on port1
      operation2 : in  std_logic;                     -- 0=read, 1=write on port2
      ready1     : in  std_logic;                     -- handshake from CPU1
      ready2     : in  std_logic;                     -- handshake from CPU2
      addr1      : in  std_logic_vector(2 downto 0);
      addr2      : in  std_logic_vector(2 downto 0);
      data_in1   : in  std_logic_vector(31 downto 0); -- CPU→SDRAM data
      data_in2   : in  std_logic_vector(31 downto 0);
      data_out1  : out std_logic_vector(31 downto 0); -- SDRAM→CPU data
      data_out2  : out std_logic_vector(31 downto 0);
      -- DEBUG OUTPUT
      debug_sdram_ready : out std_logic
    );
  end component;

  -- Internal signals for cache‐to‐cache traffic
  signal cpu0_cache_to_cache_req              : std_logic;
  signal cpu0_cache_to_cache_req_addr         : std_logic_vector(2 downto 0);
  signal cpu0_cache_to_cache_resp_data        : std_logic_vector(31 downto 0);
  signal cpu0_cache_to_cache_response         : std_logic;
  signal cpu0_cache_to_cache_response_out_ready : std_logic;
  signal cpu0_wr_req_out                      : std_logic;
  signal cpu0_rd_req_out                      : std_logic;
  signal cpu0_req_addr_out                    : std_logic_vector(2 downto 0);

  signal cpu1_cache_to_cache_req              : std_logic;
  signal cpu1_cache_to_cache_req_addr         : std_logic_vector(2 downto 0);
  signal cpu1_cache_to_cache_resp_data        : std_logic_vector(31 downto 0);
  signal cpu1_cache_to_cache_response         : std_logic;
  signal cpu1_cache_to_cache_response_out_ready : std_logic;
  signal cpu1_wr_req_out                      : std_logic;
  signal cpu1_rd_req_out                      : std_logic;
  signal cpu1_req_addr_out                    : std_logic_vector(2 downto 0);

  -- Read/Write enable flags from each CPU
  signal r_en1  : std_logic;
  signal wr_en1 : std_logic;
  signal r_en2  : std_logic;
  signal wr_en2 : std_logic;

  -- Combined “ready” lines into SDRAM
  signal ready1_sig : std_logic;
  signal ready2_sig : std_logic;

  -- Address buses from CPU → SDRAM
  signal sdram_addr1 : std_logic_vector(2 downto 0);
  signal sdram_addr2 : std_logic_vector(2 downto 0);

  -- Data buses CPU → SDRAM
  signal sdram_data_out1 : std_logic_vector(31 downto 0);
  signal sdram_data_out2 : std_logic_vector(31 downto 0);

  -- Data buses SDRAM → CPU
  signal sdram_data_in1  : std_logic_vector(31 downto 0);
  signal sdram_data_in2  : std_logic_vector(31 downto 0);

  -- DEBUG SIGNALS
  signal debug_cpu0_state_int   : std_logic_vector(2 downto 0);
  signal debug_cpu1_state_int   : std_logic_vector(2 downto 0);
  signal debug_cache0_state_int : std_logic_vector(2 downto 0);
  signal debug_cache1_state_int : std_logic_vector(2 downto 0);
  signal debug_sdram_ready_int  : std_logic;
  signal debug_cpu0_hit_int     : std_logic;
  signal debug_cpu1_hit_int     : std_logic;

begin

  -- DEBUG OUTPUT ASSIGNMENTS
debug_cpu0_state     &lt;= debug_cpu0_state_int;
debug_cpu1_state     &lt;= debug_cpu1_state_int;
debug_cache0_state   &lt;= debug_cache0_state_int;
debug_cache1_state   &lt;= debug_cache1_state_int;
debug_sdram_ready    &lt;= debug_sdram_ready_int;
debug_cpu0_hit       &lt;= debug_cpu0_hit_int;
debug_cpu1_hit       &lt;= debug_cpu1_hit_int;
debug_reset_active   &lt;= rst;

  -- Generate "ready" handshake for SDRAM ports
  ready1_sig &lt;= wr_en1 or r_en1;
  ready2_sig &lt;= wr_en2 or r_en2;

  -- CPU Core #0 instance
  core0: Cache_Controller
    port map(
      clk                            =&gt; clk,
      reset                          =&gt; rst,
      priority                       =&gt; cpu0_prio,
      -- CPU interface
      wantedAddress                  =&gt; cpu0_wantedAddr,
      cpu_data_in                    =&gt; cpu0_data_in,
      cpu_data_out                   =&gt; cpu0_data_out,
      cpu_req                        =&gt; cpu0_req,
      cpu_rw                         =&gt; cpu0_rw,
      cpu_ready                      =&gt; cpu0_ready,
      -- SDRAM interface
      read_en                        =&gt; r_en1,
      write_en                       =&gt; wr_en1,
      Sdram_addr                     =&gt; sdram_addr1,
      Sdram_data_in                  =&gt; sdram_data_in1,
      Sdram_data_out                 =&gt; sdram_data_out1,
      -- MSI protocol
      cpu_wr_req_in                  =&gt; cpu1_wr_req_out,
      cpu_rd_req_in                  =&gt; cpu1_rd_req_out,
      cache_to_cache_resp_in_ready   =&gt; cpu1_cache_to_cache_response_out_ready,
      cache_to_cache_resp_in         =&gt; cpu1_cache_to_cache_response,
      cache_to_cache_req_in          =&gt; cpu1_cache_to_cache_req,
      cache_to_cache_req_address_in  =&gt; cpu1_cache_to_cache_req_addr,
      cache_to_cache_resp_in_data    =&gt; cpu1_cache_to_cache_resp_data,
      cpu_req_addr_in                =&gt; cpu1_req_addr_out,
      cpu_wr_req_out                 =&gt; cpu0_wr_req_out,
      cpu_rd_req_out                 =&gt; cpu0_rd_req_out,
      cache_to_cache_resp_out_ready  =&gt; cpu0_cache_to_cache_response_out_ready,
      cache_to_cache_resp_out        =&gt; cpu0_cache_to_cache_response,
      cache_to_cache_req_out         =&gt; cpu0_cache_to_cache_req,
      cache_to_cache_req_address_out =&gt; cpu0_cache_to_cache_req_addr,
      cache_to_cache_resp_out_data   =&gt; cpu0_cache_to_cache_resp_data,
      cpu_req_addr_out               =&gt; cpu0_req_addr_out,
      -- DEBUG
      debug_cpu_state                =&gt; debug_cpu0_state_int,
      debug_cache_state              =&gt; debug_cache0_state_int,
      debug_cache_hit                =&gt; debug_cpu0_hit_int
    );

  -- CPU Core #1 instance
  core1: Cache_Controller
    port map(
      clk                            =&gt; clk,
      reset                          =&gt; rst,
      priority                       =&gt; cpu1_prio,
      -- CPU interface
      wantedAddress                  =&gt; cpu1_wantedAddr,
      cpu_data_in                    =&gt; cpu1_data_in,
      cpu_data_out                   =&gt; cpu1_data_out,
      cpu_req                        =&gt; cpu1_req,
      cpu_rw                         =&gt; cpu1_rw,
      cpu_ready                      =&gt; cpu1_ready,
      -- SDRAM interface
      read_en                        =&gt; r_en2,
      write_en                       =&gt; wr_en2,
      Sdram_addr                     =&gt; sdram_addr2,
      Sdram_data_in                  =&gt; sdram_data_in2,
      Sdram_data_out                 =&gt; sdram_data_out2,
      -- MSI protocol
      cpu_wr_req_in                  =&gt; cpu0_wr_req_out,
      cpu_rd_req_in                  =&gt; cpu0_rd_req_out,
      cache_to_cache_resp_in_ready   =&gt; cpu0_cache_to_cache_response_out_ready,
      cache_to_cache_resp_in         =&gt; cpu0_cache_to_cache_response,
      cache_to_cache_req_in          =&gt; cpu0_cache_to_cache_req,
      cache_to_cache_req_address_in  =&gt; cpu0_cache_to_cache_req_addr,
      cache_to_cache_resp_in_data    =&gt; cpu0_cache_to_cache_resp_data,
      cpu_req_addr_in                =&gt; cpu0_req_addr_out,
      cpu_wr_req_out                 =&gt; cpu1_wr_req_out,
      cpu_rd_req_out                 =&gt; cpu1_rd_req_out,
      cache_to_cache_resp_out_ready  =&gt; cpu1_cache_to_cache_response_out_ready,
      cache_to_cache_resp_out        =&gt; cpu1_cache_to_cache_response,
      cache_to_cache_req_out         =&gt; cpu1_cache_to_cache_req,
      cache_to_cache_req_address_out =&gt; cpu1_cache_to_cache_req_addr,
      cache_to_cache_resp_out_data   =&gt; cpu1_cache_to_cache_resp_data,
      cpu_req_addr_out               =&gt; cpu1_req_addr_out,
      -- DEBUG
      debug_cpu_state                =&gt; debug_cpu1_state_int,
      debug_cache_state              =&gt; debug_cache1_state_int,
      debug_cache_hit                =&gt; debug_cpu1_hit_int
    );

  -- SDRAM instance (port‐interleaved two‐port memory)
  sdram0: sdram
    port map(
      clk        =&gt; clk,
      reset      =&gt; rst,
      operation1 =&gt; wr_en1,           -- write when wr_en1='1'
      operation2 =&gt; wr_en2,           -- write when wr_en2='1'
      ready1     =&gt; ready1_sig,
      ready2     =&gt; ready2_sig,
      addr1      =&gt; sdram_addr1,
      addr2      =&gt; sdram_addr2,
      data_in1   =&gt; sdram_data_out1,  -- CPU0 → SDRAM
      data_in2   =&gt; sdram_data_out2,  -- CPU1 → SDRAM
      data_out1  =&gt; sdram_data_in1,   -- SDRAM → CPU0
      data_out2  =&gt; sdram_data_in2,   -- SDRAM → CPU1
      debug_sdram_ready =&gt; debug_sdram_ready_int
    );

end architecture bdf_type;
</vhdl>
  <vhdl name="Cache_Controller">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity Cache_Controller is
    port (
        clk            : in std_logic;
        reset          : in std_logic;
        priority       : in std_logic;
        
        -- CPU interface
        wantedAddress  : in std_logic_vector(2 downto 0);
        cpu_data_in    : in std_logic_vector(31 downto 0);  -- Datos para escritura
        cpu_data_out   : out std_logic_vector(31 downto 0); -- Datos leídos
        cpu_req        : in std_logic;                       -- '1' para iniciar operación
        cpu_rw         : in std_logic;                       -- '0': read, '1': write
        cpu_ready      : out std_logic;                      -- '1' cuando operación completa
        
        -- SDRAM interface
        read_en        : out std_logic;
        write_en       : out std_logic;
        Sdram_addr     : out std_logic_vector(2 downto 0);
        Sdram_data_in  : in std_logic_vector(31 downto 0);
        Sdram_data_out : out std_logic_vector(31 downto 0);
        
        -- MSI protocol - outgoing requests
        cpu_wr_req_out : out std_logic;
        cpu_rd_req_out : out std_logic;
        cpu_req_addr_out : out std_logic_vector(2 downto 0);
        
        -- MSI protocol - incoming requests (snooping)
        cpu_wr_req_in  : in std_logic;
        cpu_rd_req_in  : in std_logic;
        cpu_req_addr_in : in std_logic_vector(2 downto 0);
        
        -- Cache-to-cache communication - outgoing
        cache_to_cache_req_out : out std_logic;
        cache_to_cache_req_address_out : out std_logic_vector(2 downto 0);
        cache_to_cache_resp_out : out std_logic;
        cache_to_cache_resp_out_ready : out std_logic;
        cache_to_cache_resp_out_data : out std_logic_vector(31 downto 0);
        
        -- Cache-to-cache communication - incoming
        cache_to_cache_req_in : in std_logic;
        cache_to_cache_req_address_in : in std_logic_vector(2 downto 0);
        cache_to_cache_resp_in : in std_logic;
        cache_to_cache_resp_in_ready : in std_logic;
        cache_to_cache_resp_in_data : in std_logic_vector(31 downto 0);
        
        -- DEBUG OUTPUTS
        debug_cpu_state : out std_logic_vector(2 downto 0);
        debug_cache_state : out std_logic_vector(2 downto 0);
        debug_cache_hit : out std_logic
    );
end Cache_Controller;

architecture Behavioral of Cache_Controller is
    -- Cache configuration
    constant CACHE_SIZE : integer := 4;
    
    -- MSI states
    type msi_state_type is (MSI_INVALID, MSI_SHARED, MSI_MODIFIED);
    
    -- Cache line structure
    type cache_line_type is record
        msi_state : msi_state_type;
        address   : std_logic_vector(2 downto 0);
        data      : std_logic_vector(31 downto 0);
        valid     : std_logic;
    end record;
    
    type cache_array_type is array (0 to CACHE_SIZE-1) of cache_line_type;
    
    -- CPU operation states
    type cpu_state_type is (CPU_IDLE, CPU_READ, CPU_WRITE, CPU_WAIT_CACHE, CPU_WAIT_SDRAM);
    
    -- Cache operation states  
    type cache_state_type is (CACHE_CHECK, CACHE_HIT, CACHE_MISS, CACHE_COHERENCE, CACHE_SDRAM_ACCESS, CACHE_SDRAM_WAIT, CACHE_EVICTION);
    
    -- Signals
    signal cache_mem : cache_array_type;
    signal cpu_state : cpu_state_type;
    signal cache_state : cache_state_type;
    signal current_address : std_logic_vector(2 downto 0);
    signal current_data : std_logic_vector(31 downto 0);
    signal cache_hit_flag : std_logic;
    signal cache_hit_index : integer range 0 to CACHE_SIZE-1;
    signal evict_index : integer range 0 to CACHE_SIZE-1;
    signal operation_type : std_logic; -- 0 = read, 1 = write
    signal cycle_counter : integer range 0 to 15;
    signal eviction_needed : std_logic;
    signal eviction_done : std_logic;
    signal sdram_request_pending : std_logic;
    
    -- Helper functions
    function find_cache_line(
        addr : std_logic_vector(2 downto 0);
        cache_mem : cache_array_type
    ) return integer is
    begin
        for i in 0 to CACHE_SIZE-1 loop
            if cache_mem(i).valid = '1' and cache_mem(i).address = addr then
                return i;
            end if;
        end loop;
        return -1; -- Not found
    end function;
    
    function find_empty_line(cache_mem : cache_array_type) return integer is
    begin
        for i in 0 to CACHE_SIZE-1 loop
            if cache_mem(i).valid = '0' then
                return i;
            end if;
        end loop;
        return -1; -- Cache full
    end function;

begin

    -- Main cache controller process
    main_process: process(clk, reset)
        variable hit_index : integer;
        variable empty_index : integer;
    begin
        if reset = '1' then
            -- Initialize cache
            for i in 0 to CACHE_SIZE-1 loop
                cache_mem(i).msi_state &lt;= MSI_INVALID;
                cache_mem(i).address &lt;= (others =&gt; '0');
                cache_mem(i).data &lt;= (others =&gt; '0');
                cache_mem(i).valid &lt;= '0';
            end loop;
            
            -- Reset state machines
            cpu_state &lt;= CPU_IDLE;
            cache_state &lt;= CACHE_CHECK;
            
            -- Reset outputs
            read_en &lt;= '0';
            write_en &lt;= '0';
            cpu_wr_req_out &lt;= '0';
            cpu_rd_req_out &lt;= '0';
            cache_to_cache_req_out &lt;= '0';
            cache_to_cache_resp_out &lt;= '0';
            cache_to_cache_resp_out_ready &lt;= '0';
            cpu_ready &lt;= '0';
            cpu_data_out &lt;= (others =&gt; '0');
            
            -- Reset internal signals
            current_address &lt;= (others =&gt; '0');
            current_data &lt;= (others =&gt; '0');
            cache_hit_flag &lt;= '0';
            cache_hit_index &lt;= 0;
            operation_type &lt;= '0';
            evict_index &lt;= 0;
            cycle_counter &lt;= 0;
            eviction_needed &lt;= '0';
            eviction_done &lt;= '0';
            sdram_request_pending &lt;= '0';
            
        elsif rising_edge(clk) then
            -- Default signal values
            read_en &lt;= '0';
            write_en &lt;= '0';
            cpu_wr_req_out &lt;= '0';
            cpu_rd_req_out &lt;= '0';
            cache_to_cache_req_out &lt;= '0';
            cache_to_cache_resp_out &lt;= '0';
            cache_to_cache_resp_out_ready &lt;= '0';
            
            -- Handle snooping requests from other caches
            if cache_to_cache_req_in = '1' then
                hit_index := find_cache_line(cache_to_cache_req_address_in, cache_mem);
                if hit_index &gt;= 0 then
                    if cache_mem(hit_index).msi_state = MSI_MODIFIED then
                        -- Provide data and transition to shared
                        cache_to_cache_resp_out &lt;= '1';
                        cache_to_cache_resp_out_data &lt;= cache_mem(hit_index).data;
                        cache_mem(hit_index).msi_state &lt;= MSI_SHARED;
                    elsif cache_mem(hit_index).msi_state = MSI_SHARED then
                        -- Provide data, stay shared
                        cache_to_cache_resp_out &lt;= '1';
                        cache_to_cache_resp_out_data &lt;= cache_mem(hit_index).data;
                    end if;
                else
                    cache_to_cache_resp_out &lt;= '0';
                end if;
                cache_to_cache_resp_out_ready &lt;= '1';
            end if;
            
            -- Handle invalidation requests
            if cpu_wr_req_in = '1' then
                hit_index := find_cache_line(cpu_req_addr_in, cache_mem);
                if hit_index &gt;= 0 then
                    cache_mem(hit_index).msi_state &lt;= MSI_INVALID;
                    cache_mem(hit_index).valid &lt;= '0';
                end if;
            end if;
            
            -- Main CPU state machine
            case cpu_state is
                when CPU_IDLE =&gt;
                    cpu_ready &lt;= '0';
                    -- Handshaking: iniciar operación cuando CPU solicite
                    if cpu_req = '1' then
                        current_address &lt;= wantedAddress;
                        if cpu_rw = '0' then
                            -- Operación de lectura
                            cpu_state &lt;= CPU_READ;
                            operation_type &lt;= '0';
                            cpu_rd_req_out &lt;= '1';
                            cpu_req_addr_out &lt;= wantedAddress;
                        else
                            -- Operación de escritura
                            cpu_state &lt;= CPU_WRITE;
                            operation_type &lt;= '1';
                            current_data &lt;= cpu_data_in;
                            cpu_wr_req_out &lt;= '1';
                            cpu_req_addr_out &lt;= wantedAddress;
                        end if;
                        cache_state &lt;= CACHE_CHECK;
                    end if;
                
                when CPU_READ | CPU_WRITE =&gt;
                    case cache_state is
                        when CACHE_CHECK =&gt;
                            hit_index := find_cache_line(current_address, cache_mem);
                            if hit_index &gt;= 0 and cache_mem(hit_index).msi_state /= MSI_INVALID then
                                -- Cache hit
                                cache_hit_flag &lt;= '1';
                                cache_hit_index &lt;= hit_index;
                                cache_state &lt;= CACHE_HIT;
                            else
                                -- Cache miss
                                cache_hit_flag &lt;= '0';
                                cache_state &lt;= CACHE_MISS;
                            end if;
                        
                        when CACHE_HIT =&gt;
                            if operation_type = '0' then
                                -- Read hit - return data
                                cpu_data_out &lt;= cache_mem(cache_hit_index).data;
                                cpu_ready &lt;= '1';
                                cpu_state &lt;= CPU_IDLE;
                                cpu_rd_req_out &lt;= '0';
                                cache_state &lt;= CACHE_CHECK;
                            else
                                -- Write hit - check MSI state
                                cache_mem(cache_hit_index).data &lt;= current_data;
                                if cache_mem(cache_hit_index).msi_state = MSI_SHARED then
                                    -- Request invalidation of other copies
                                    cpu_wr_req_out &lt;= '1';
                                    cpu_req_addr_out &lt;= current_address;
                                    -- Wait one cycle for invalidation, then transition to MODIFIED
                                    cache_mem(cache_hit_index).msi_state &lt;= MSI_MODIFIED;
                                    cpu_ready &lt;= '1';
                                    cpu_state &lt;= CPU_IDLE;
                                    cpu_wr_req_out &lt;= '0';
                                    cache_state &lt;= CACHE_CHECK;
                                elsif cache_mem(cache_hit_index).msi_state = MSI_MODIFIED then
                                    -- Already modified, just update data
                                    cache_mem(cache_hit_index).msi_state &lt;= MSI_MODIFIED;
                                    cpu_ready &lt;= '1';
                                    cpu_state &lt;= CPU_IDLE;
                                    cpu_wr_req_out &lt;= '0';
                                    cache_state &lt;= CACHE_CHECK;
                                end if;
                            end if;
                        
                        when CACHE_MISS =&gt;
                            -- Try cache-to-cache transfer first
                            cache_to_cache_req_out &lt;= '1';
                            cache_to_cache_req_address_out &lt;= current_address;
                            cache_state &lt;= CACHE_COHERENCE;
                        
                        when CACHE_COHERENCE =&gt;
                            if cache_to_cache_resp_in_ready = '1' then
                                if cache_to_cache_resp_in = '1' then
                                    -- Cache-to-cache hit
                                    empty_index := find_empty_line(cache_mem);
                                    if empty_index &gt;= 0 then
                                        -- Use empty line
                                        cache_mem(empty_index).valid &lt;= '1';
                                        cache_mem(empty_index).address &lt;= current_address;
                                        cache_mem(empty_index).data &lt;= cache_to_cache_resp_in_data;
                                        if operation_type = '0' then
                                            cache_mem(empty_index).msi_state &lt;= MSI_SHARED;
                                            cpu_data_out &lt;= cache_to_cache_resp_in_data;
                                        else
                                            cache_mem(empty_index).msi_state &lt;= MSI_MODIFIED;
                                            cache_mem(empty_index).data &lt;= current_data;
                                        end if;
                                        cpu_ready &lt;= '1';
                                        cpu_state &lt;= CPU_IDLE;
                                        if operation_type = '0' then
                                            cpu_rd_req_out &lt;= '0';
                                        else
                                            cpu_wr_req_out &lt;= '0';
                                        end if;
                                        cache_state &lt;= CACHE_CHECK;
                                    else
                                        -- Need eviction - check if writeback needed
                                        if cache_mem(evict_index).msi_state = MSI_MODIFIED then
                                            eviction_needed &lt;= '1';
                                            cache_state &lt;= CACHE_EVICTION;
                                        else
                                            -- Direct replacement - no writeback needed
                                            cache_mem(evict_index).valid &lt;= '1';
                                            cache_mem(evict_index).address &lt;= current_address;
                                            cache_mem(evict_index).data &lt;= cache_to_cache_resp_in_data;
                                            if operation_type = '0' then
                                                cache_mem(evict_index).msi_state &lt;= MSI_SHARED;
                                                cpu_data_out &lt;= cache_to_cache_resp_in_data;
                                            else
                                                cache_mem(evict_index).msi_state &lt;= MSI_MODIFIED;
                                                cache_mem(evict_index).data &lt;= current_data;
                                            end if;
                                            evict_index &lt;= (evict_index + 1) mod CACHE_SIZE;
                                            cpu_ready &lt;= '1';
                                            cpu_state &lt;= CPU_IDLE;
                                            if operation_type = '0' then
                                                cpu_rd_req_out &lt;= '0';
                                            else
                                                cpu_wr_req_out &lt;= '0';
                                            end if;
                                            cache_state &lt;= CACHE_CHECK;
                                        end if;
                                    end if;
                                else
                                    -- Cache-to-cache miss, go to SDRAM
                                    cache_state &lt;= CACHE_SDRAM_ACCESS;
                                end if;
                            end if;
                        
                        when CACHE_SDRAM_ACCESS =&gt;
                            -- Access SDRAM for the current operation
                            if sdram_request_pending = '0' then
                                -- First cycle: send request to SDRAM
                                if operation_type = '0' then
                                    read_en &lt;= '1';
                                else
                                    write_en &lt;= '1';
                                    Sdram_data_out &lt;= current_data;
                                end if;
                                Sdram_addr &lt;= current_address;
                                sdram_request_pending &lt;= '1';
                                cache_state &lt;= CACHE_SDRAM_WAIT;
                            end if;
                        
                        when CACHE_SDRAM_WAIT =&gt;
                            -- Wait for SDRAM response and allocate cache line
                            if sdram_request_pending = '1' then
                                sdram_request_pending &lt;= '0';
                                
                                empty_index := find_empty_line(cache_mem);
                                if empty_index &gt;= 0 then
                                    -- Use empty line
                                    cache_mem(empty_index).valid &lt;= '1';
                                    cache_mem(empty_index).address &lt;= current_address;
                                    if operation_type = '0' then
                                        cache_mem(empty_index).data &lt;= Sdram_data_in;
                                        cache_mem(empty_index).msi_state &lt;= MSI_SHARED;
                                        cpu_data_out &lt;= Sdram_data_in;
                                    else
                                        cache_mem(empty_index).data &lt;= current_data;
                                        cache_mem(empty_index).msi_state &lt;= MSI_MODIFIED;
                                    end if;
                                    cpu_ready &lt;= '1';
                                    cpu_state &lt;= CPU_IDLE;
                                    if operation_type = '0' then
                                        cpu_rd_req_out &lt;= '0';
                                    else
                                        cpu_wr_req_out &lt;= '0';
                                    end if;
                                    cache_state &lt;= CACHE_CHECK;
                                else
                                    -- Need eviction - check if writeback needed
                                    if cache_mem(evict_index).msi_state = MSI_MODIFIED then
                                        eviction_needed &lt;= '1';
                                        cache_state &lt;= CACHE_EVICTION;
                                    else
                                        -- Direct replacement - no writeback needed
                                        cache_mem(evict_index).valid &lt;= '1';
                                        cache_mem(evict_index).address &lt;= current_address;
                                        if operation_type = '0' then
                                            cache_mem(evict_index).data &lt;= Sdram_data_in;
                                            cache_mem(evict_index).msi_state &lt;= MSI_SHARED;
                                            cpu_data_out &lt;= Sdram_data_in;
                                        else
                                            cache_mem(evict_index).data &lt;= current_data;
                                            cache_mem(evict_index).msi_state &lt;= MSI_MODIFIED;
                                        end if;
                                        evict_index &lt;= (evict_index + 1) mod CACHE_SIZE;
                                        cpu_ready &lt;= '1';
                                        cpu_state &lt;= CPU_IDLE;
                                        if operation_type = '0' then
                                            cpu_rd_req_out &lt;= '0';
                                        else
                                            cpu_wr_req_out &lt;= '0';
                                        end if;
                                        cache_state &lt;= CACHE_CHECK;
                                    end if;
                                end if;
                            end if;
                        
                        when CACHE_EVICTION =&gt;
                            -- Handle eviction: write back modified line to SDRAM first
                            if eviction_needed = '1' then
                                -- First cycle: write back the evicted line
                                write_en &lt;= '1';
                                Sdram_addr &lt;= cache_mem(evict_index).address;
                                Sdram_data_out &lt;= cache_mem(evict_index).data;
                                eviction_needed &lt;= '0';
                                eviction_done &lt;= '1';
                            elsif eviction_done = '1' then
                                -- Second cycle: load new data into the cache line
                                cache_mem(evict_index).valid &lt;= '1';
                                cache_mem(evict_index).address &lt;= current_address;
                                
                                -- Determine source of data based on previous state
                                if cache_state = CACHE_COHERENCE then
                                    -- Data comes from cache-to-cache transfer
                                    cache_mem(evict_index).data &lt;= cache_to_cache_resp_in_data;
                                    if operation_type = '0' then
                                        cache_mem(evict_index).msi_state &lt;= MSI_SHARED;
                                        cpu_data_out &lt;= cache_to_cache_resp_in_data;
                                    else
                                        cache_mem(evict_index).msi_state &lt;= MSI_MODIFIED;
                                        cache_mem(evict_index).data &lt;= current_data;
                                    end if;
                                else
                                    -- Data comes from SDRAM
                                    if operation_type = '0' then
                                        cache_mem(evict_index).data &lt;= Sdram_data_in;
                                        cache_mem(evict_index).msi_state &lt;= MSI_SHARED;
                                        cpu_data_out &lt;= Sdram_data_in;
                                        read_en &lt;= '1';
                                        Sdram_addr &lt;= current_address;
                                    else
                                        cache_mem(evict_index).data &lt;= current_data;
                                        cache_mem(evict_index).msi_state &lt;= MSI_MODIFIED;
                                        write_en &lt;= '1';
                                        Sdram_addr &lt;= current_address;
                                        Sdram_data_out &lt;= current_data;
                                    end if;
                                end if;
                                
                                evict_index &lt;= (evict_index + 1) mod CACHE_SIZE;
                                eviction_done &lt;= '0';
                                cpu_ready &lt;= '1';
                                cpu_state &lt;= CPU_IDLE;
                                if operation_type = '0' then
                                    cpu_rd_req_out &lt;= '0';
                                else
                                    cpu_wr_req_out &lt;= '0';
                                end if;
                                cache_state &lt;= CACHE_CHECK;
                            end if;
                    end case;
                
                when others =&gt;
                    cpu_state &lt;= CPU_IDLE;
            end case;
        end if;
    end process;

end Behavioral;
</vhdl>
  <vhdl name="sdram">
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity sdram is
    port(
        clk        : in  std_logic;
        reset      : in  std_logic;
        operation1 : in  std_logic;                     -- 0=read, 1=write on port1
        operation2 : in  std_logic;                     -- 0=read, 1=write on port2
        ready1     : in  std_logic;                     -- handshake from CPU1
        ready2     : in  std_logic;                     -- handshake from CPU2
        addr1      : in  std_logic_vector(2 downto 0);
        addr2      : in  std_logic_vector(2 downto 0);
        data_in1   : in  std_logic_vector(31 downto 0); -- CPU→SDRAM data
        data_in2   : in  std_logic_vector(31 downto 0);
        data_out1  : out std_logic_vector(31 downto 0); -- SDRAM→CPU data
        data_out2  : out std_logic_vector(31 downto 0)
    );
end sdram;

architecture Behavioral of sdram is
    type memory_array is array (0 to 7) of std_logic_vector(31 downto 0);
    signal memory : memory_array;
    signal port1_active : std_logic;
    signal port2_active : std_logic;
begin
    process(clk, reset)
    begin
        if reset = '1' then
            -- Initialize memory with test pattern
            memory(0) &lt;= x"00000000";
            memory(1) &lt;= x"11111111";
            memory(2) &lt;= x"22222222";
            memory(3) &lt;= x"33333333";
            memory(4) &lt;= x"44444444";
            memory(5) &lt;= x"55555555";
            memory(6) &lt;= x"66666666";
            memory(7) &lt;= x"77777777";
            port1_active &lt;= '0';
            port2_active &lt;= '0';
        elsif rising_edge(clk) then
            -- Clear previous activity flags
            port1_active &lt;= '0';
            port2_active &lt;= '0';
            
            -- Check for simultaneous access to same address
            if ready1 = '1' and ready2 = '1' and addr1 = addr2 then
                -- Conflict: prioritize port1 (can be changed based on system requirements)
                port1_active &lt;= '1';
                if operation1 = '1' then
                    -- Port1 write has priority
                    memory(to_integer(unsigned(addr1))) &lt;= data_in1;
                else
                    -- Port1 read
                    data_out1 &lt;= memory(to_integer(unsigned(addr1)));
                end if;
                -- Port2 is delayed to next cycle (could implement queuing)
            else
                -- No conflict or only one port active
                -- Port 1 operations
                if ready1 = '1' then
                    port1_active &lt;= '1';
                    if operation1 = '1' then
                        -- Write
                        memory(to_integer(unsigned(addr1))) &lt;= data_in1;
                    else
                        -- Read
                        data_out1 &lt;= memory(to_integer(unsigned(addr1)));
                    end if;
                end if;
                
                -- Port 2 operations  
                if ready2 = '1' then
                    port2_active &lt;= '1';
                    if operation2 = '1' then
                        -- Write
                        memory(to_integer(unsigned(addr2))) &lt;= data_in2;
                    else
                        -- Read
                        data_out2 &lt;= memory(to_integer(unsigned(addr2)));
                    end if;
                end if;
            end if;
        end if;
    end process;
end Behavioral;
</vhdl>
</project>
